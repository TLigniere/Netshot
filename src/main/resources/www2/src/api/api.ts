/* tslint:disable */
/* eslint-disable */
/**
 * Netshot API
 * Network Infrastructure Configuration and Compliance Management Software
 *
 * The version of the OpenAPI document: 1
 * Contact: contact@netfishers.onl
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiTokenRestApiView
 */
export interface ApiTokenRestApiView {
    /**
     * 
     * @type {number}
     * @memberof ApiTokenRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiTokenRestApiView
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiTokenRestApiView
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface AttributeDefinitionRestApiView
 */
export interface AttributeDefinitionRestApiView {
    /**
     * 
     * @type {string}
     * @memberof AttributeDefinitionRestApiView
     */
    'type'?: AttributeDefinitionRestApiViewTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AttributeDefinitionRestApiView
     */
    'level'?: AttributeDefinitionRestApiViewLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof AttributeDefinitionRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributeDefinitionRestApiView
     */
    'title'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AttributeDefinitionRestApiView
     */
    'comparable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AttributeDefinitionRestApiView
     */
    'searchable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AttributeDefinitionRestApiView
     */
    'checkable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AttributeDefinitionRestApiView
     */
    'dump'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AttributeDefinitionRestApiView
     */
    'preDump'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributeDefinitionRestApiView
     */
    'postDump'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributeDefinitionRestApiView
     */
    'preLineDump'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributeDefinitionRestApiView
     */
    'postLineDump'?: string;
}

export const AttributeDefinitionRestApiViewTypeEnum = {
    Numeric: 'NUMERIC',
    Text: 'TEXT',
    Longtext: 'LONGTEXT',
    Date: 'DATE',
    Binary: 'BINARY',
    Binaryfile: 'BINARYFILE'
} as const;

export type AttributeDefinitionRestApiViewTypeEnum = typeof AttributeDefinitionRestApiViewTypeEnum[keyof typeof AttributeDefinitionRestApiViewTypeEnum];
export const AttributeDefinitionRestApiViewLevelEnum = {
    Device: 'DEVICE',
    Config: 'CONFIG'
} as const;

export type AttributeDefinitionRestApiViewLevelEnum = typeof AttributeDefinitionRestApiViewLevelEnum[keyof typeof AttributeDefinitionRestApiViewLevelEnum];

/**
 * 
 * @export
 * @interface CheckComplianceTask
 */
export interface CheckComplianceTask extends TaskRestApiView {
}


/**
 * 
 * @export
 * @interface CheckGroupComplianceTask
 */
export interface CheckGroupComplianceTask extends TaskRestApiView {
}


/**
 * 
 * @export
 * @interface CheckGroupSoftwareTask
 */
export interface CheckGroupSoftwareTask extends TaskRestApiView {
}


/**
 * 
 * @export
 * @interface ClusterMemberRestApiView
 */
export interface ClusterMemberRestApiView {
    /**
     * 
     * @type {boolean}
     * @memberof ClusterMemberRestApiView
     */
    'local'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterMemberRestApiView
     */
    'instanceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterMemberRestApiView
     */
    'hostname'?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterMemberRestApiView
     */
    'clusteringVersion'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterMemberRestApiView
     */
    'masterPriority'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterMemberRestApiView
     */
    'runnerPriority'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterMemberRestApiView
     */
    'runnerWeight'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterMemberRestApiView
     */
    'appVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterMemberRestApiView
     */
    'jvmVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterMemberRestApiView
     */
    'driverHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterMemberRestApiView
     */
    'status'?: ClusterMemberRestApiViewStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof ClusterMemberRestApiView
     */
    'lastStatusChangeTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterMemberRestApiView
     */
    'lastSeenTime'?: number;
}

export const ClusterMemberRestApiViewStatusEnum = {
    Member: 'MEMBER',
    Master: 'MASTER',
    Expired: 'EXPIRED',
    Negotiating: 'NEGOTIATING'
} as const;

export type ClusterMemberRestApiViewStatusEnum = typeof ClusterMemberRestApiViewStatusEnum[keyof typeof ClusterMemberRestApiViewStatusEnum];

/**
 * 
 * @export
 * @interface ConfigAttributeRestApiView
 */
export interface ConfigAttributeRestApiView {
    /**
     * 
     * @type {string}
     * @memberof ConfigAttributeRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigAttributeRestApiView
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ConfigBinaryAttribute
 */
export interface ConfigBinaryAttribute extends ConfigAttributeRestApiView {
    /**
     * 
     * @type {boolean}
     * @memberof ConfigBinaryAttribute
     */
    'assumption'?: boolean;
}
/**
 * 
 * @export
 * @interface ConfigBinaryFileAttribute
 */
export interface ConfigBinaryFileAttribute extends ConfigAttributeRestApiView {
    /**
     * 
     * @type {string}
     * @memberof ConfigBinaryFileAttribute
     */
    'originalName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConfigBinaryFileAttribute
     */
    'fileSize'?: number;
}
/**
 * 
 * @export
 * @interface ConfigBinaryFileAttributeAllOf
 */
export interface ConfigBinaryFileAttributeAllOf {
    /**
     * 
     * @type {string}
     * @memberof ConfigBinaryFileAttributeAllOf
     */
    'originalName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConfigBinaryFileAttributeAllOf
     */
    'fileSize'?: number;
}
/**
 * 
 * @export
 * @interface ConfigLongTextAttribute
 */
export interface ConfigLongTextAttribute extends ConfigAttributeRestApiView {
}
/**
 * 
 * @export
 * @interface ConfigNumericAttribute
 */
export interface ConfigNumericAttribute extends ConfigAttributeRestApiView {
    /**
     * 
     * @type {number}
     * @memberof ConfigNumericAttribute
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface ConfigRestApiView
 */
export interface ConfigRestApiView {
    /**
     * 
     * @type {Set<ConfigAttributeRestApiView>}
     * @memberof ConfigRestApiView
     */
    'attributes'?: Set<ConfigAttributeRestApiView>;
    /**
     * 
     * @type {string}
     * @memberof ConfigRestApiView
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigRestApiView
     */
    'changeDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConfigRestApiView
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface ConfigTextAttribute
 */
export interface ConfigTextAttribute extends ConfigAttributeRestApiView {
    /**
     * 
     * @type {string}
     * @memberof ConfigTextAttribute
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {Set<DeviceAttribute>}
     * @memberof Device
     */
    'attributes'?: Set<DeviceAttribute>;
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    'autoTryCredentials'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'changeDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'comments'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'contact'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'creator'?: string;
    /**
     * 
     * @type {DeviceCredentialSet}
     * @memberof Device
     */
    'specificCredentialSet'?: DeviceCredentialSet;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'driver'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'eolDate'?: string;
    /**
     * 
     * @type {Module}
     * @memberof Device
     */
    'eolModule'?: Module;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'eosDate'?: string;
    /**
     * 
     * @type {Module}
     * @memberof Device
     */
    'eosModule'?: Module;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'family'?: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'location'?: string;
    /**
     * 
     * @type {Network4Address}
     * @memberof Device
     */
    'mgmtAddress'?: Network4Address;
    /**
     * 
     * @type {Domain}
     * @memberof Device
     */
    'mgmtDomain'?: Domain;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'networkClass'?: DeviceNetworkClassEnum;
    /**
     * 
     * @type {Set<DeviceGroup>}
     * @memberof Device
     */
    'ownerGroups'?: Set<DeviceGroup>;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'serialNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'softwareLevel'?: DeviceSoftwareLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'softwareVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'status'?: DeviceStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    'sshPort'?: number;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    'telnetPort'?: number;
    /**
     * 
     * @type {Network4Address}
     * @memberof Device
     */
    'connectAddress'?: Network4Address;
    /**
     * 
     * @type {Array<number>}
     * @memberof Device
     */
    'credentialSetIds'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'realDeviceType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    'endOfLife'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    'endOfSale'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    'compliant'?: boolean;
}

export const DeviceNetworkClassEnum = {
    Firewall: 'FIREWALL',
    Loadbalancer: 'LOADBALANCER',
    Router: 'ROUTER',
    Server: 'SERVER',
    Switch: 'SWITCH',
    Switchrouter: 'SWITCHROUTER',
    Accesspoint: 'ACCESSPOINT',
    Wirelesscontroller: 'WIRELESSCONTROLLER',
    Consoleserver: 'CONSOLESERVER',
    Unknown: 'UNKNOWN'
} as const;

export type DeviceNetworkClassEnum = typeof DeviceNetworkClassEnum[keyof typeof DeviceNetworkClassEnum];
export const DeviceSoftwareLevelEnum = {
    Gold: 'GOLD',
    Silver: 'SILVER',
    Bronze: 'BRONZE',
    Unknown: 'UNKNOWN'
} as const;

export type DeviceSoftwareLevelEnum = typeof DeviceSoftwareLevelEnum[keyof typeof DeviceSoftwareLevelEnum];
export const DeviceStatusEnum = {
    Disabled: 'DISABLED',
    Inproduction: 'INPRODUCTION',
    Preproduction: 'PREPRODUCTION'
} as const;

export type DeviceStatusEnum = typeof DeviceStatusEnum[keyof typeof DeviceStatusEnum];

/**
 * 
 * @export
 * @interface DeviceAttribute
 */
export interface DeviceAttribute {
    /**
     * 
     * @type {string}
     * @memberof DeviceAttribute
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceAttribute
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface DeviceAttributeRestApiView
 */
export interface DeviceAttributeRestApiView {
    /**
     * 
     * @type {string}
     * @memberof DeviceAttributeRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceAttributeRestApiView
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface DeviceBinaryAttribute
 */
export interface DeviceBinaryAttribute extends DeviceAttribute {
    /**
     * 
     * @type {boolean}
     * @memberof DeviceBinaryAttribute
     */
    'assumption'?: boolean;
}
/**
 * 
 * @export
 * @interface DeviceBinaryAttributeAllOf
 */
export interface DeviceBinaryAttributeAllOf {
    /**
     * 
     * @type {boolean}
     * @memberof DeviceBinaryAttributeAllOf
     */
    'assumption'?: boolean;
}
/**
 * 
 * @export
 * @interface DeviceCredentialSet
 */
export interface DeviceCredentialSet {
    /**
     * 
     * @type {number}
     * @memberof DeviceCredentialSet
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceCredentialSet
     */
    'name'?: string;
    /**
     * 
     * @type {Domain}
     * @memberof DeviceCredentialSet
     */
    'mgmtDomain'?: Domain;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceCredentialSet
     */
    'deviceSpecific'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceCredentialSet
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface DeviceCredentialSetRestApiView
 */
export interface DeviceCredentialSetRestApiView {
    /**
     * 
     * @type {number}
     * @memberof DeviceCredentialSetRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceCredentialSetRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {DomainRestApiView}
     * @memberof DeviceCredentialSetRestApiView
     */
    'mgmtDomain'?: DomainRestApiView;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceCredentialSetRestApiView
     */
    'deviceSpecific'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceCredentialSetRestApiView
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface DeviceDriverRestApiView
 */
export interface DeviceDriverRestApiView {
    /**
     * 
     * @type {string}
     * @memberof DeviceDriverRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDriverRestApiView
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDriverRestApiView
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDriverRestApiView
     */
    'version'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceDriverRestApiView
     */
    'priority'?: number;
    /**
     * 
     * @type {Set<AttributeDefinitionRestApiView>}
     * @memberof DeviceDriverRestApiView
     */
    'attributes'?: Set<AttributeDefinitionRestApiView>;
    /**
     * 
     * @type {Set<string>}
     * @memberof DeviceDriverRestApiView
     */
    'protocols'?: Set<DeviceDriverRestApiViewProtocolsEnum>;
    /**
     * 
     * @type {Set<string>}
     * @memberof DeviceDriverRestApiView
     */
    'cliMainModes'?: Set<string>;
    /**
     * 
     * @type {string}
     * @memberof DeviceDriverRestApiView
     */
    'sourceHash'?: string;
    /**
     * 
     * @type {LocationRestApiView}
     * @memberof DeviceDriverRestApiView
     */
    'location'?: LocationRestApiView;
    /**
     * 
     * @type {SshConfigRestApiView}
     * @memberof DeviceDriverRestApiView
     */
    'sshConfig'?: SshConfigRestApiView;
    /**
     * 
     * @type {TelnetConfigRestApiView}
     * @memberof DeviceDriverRestApiView
     */
    'telnetConfig'?: TelnetConfigRestApiView;
}

export const DeviceDriverRestApiViewProtocolsEnum = {
    Telnet: 'TELNET',
    Ssh: 'SSH',
    Snmp: 'SNMP'
} as const;

export type DeviceDriverRestApiViewProtocolsEnum = typeof DeviceDriverRestApiViewProtocolsEnum[keyof typeof DeviceDriverRestApiViewProtocolsEnum];

/**
 * 
 * @export
 * @interface DeviceGroup
 */
export interface DeviceGroup {
    /**
     * 
     * @type {string}
     * @memberof DeviceGroup
     */
    'changeDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceGroup
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceGroup
     */
    'folder'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceGroup
     */
    'hiddenFromReports'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceGroup
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface DeviceGroupRestApiView
 */
export interface DeviceGroupRestApiView {
    /**
     * 
     * @type {string}
     * @memberof DeviceGroupRestApiView
     */
    'changeDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceGroupRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceGroupRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceGroupRestApiView
     */
    'folder'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceGroupRestApiView
     */
    'hiddenFromReports'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceGroupRestApiView
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface DeviceJsScriptRestApiView
 */
export interface DeviceJsScriptRestApiView {
    /**
     * 
     * @type {number}
     * @memberof DeviceJsScriptRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceJsScriptRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceJsScriptRestApiView
     */
    'script'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceJsScriptRestApiView
     */
    'deviceDriver'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceJsScriptRestApiView
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceJsScriptRestApiView
     */
    'realDeviceType'?: string;
}
/**
 * 
 * @export
 * @interface DeviceLongTextAttribute
 */
export interface DeviceLongTextAttribute extends DeviceAttribute {
}
/**
 * 
 * @export
 * @interface DeviceNumericAttribute
 */
export interface DeviceNumericAttribute extends DeviceAttribute {
    /**
     * 
     * @type {number}
     * @memberof DeviceNumericAttribute
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface DeviceNumericAttributeAllOf
 */
export interface DeviceNumericAttributeAllOf {
    /**
     * 
     * @type {number}
     * @memberof DeviceNumericAttributeAllOf
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface DeviceRestApiView
 */
export interface DeviceRestApiView {
    /**
     * 
     * @type {Set<DeviceAttributeRestApiView>}
     * @memberof DeviceRestApiView
     */
    'attributes'?: Set<DeviceAttributeRestApiView>;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceRestApiView
     */
    'autoTryCredentials'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'changeDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'comments'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'contact'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'creator'?: string;
    /**
     * 
     * @type {DeviceCredentialSetRestApiView}
     * @memberof DeviceRestApiView
     */
    'specificCredentialSet'?: DeviceCredentialSetRestApiView;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'driver'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'eolDate'?: string;
    /**
     * 
     * @type {ModuleRestApiView}
     * @memberof DeviceRestApiView
     */
    'eolModule'?: ModuleRestApiView;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'eosDate'?: string;
    /**
     * 
     * @type {ModuleRestApiView}
     * @memberof DeviceRestApiView
     */
    'eosModule'?: ModuleRestApiView;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'family'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'location'?: string;
    /**
     * 
     * @type {Network4AddressRestApiView}
     * @memberof DeviceRestApiView
     */
    'mgmtAddress'?: Network4AddressRestApiView;
    /**
     * 
     * @type {DomainRestApiView}
     * @memberof DeviceRestApiView
     */
    'mgmtDomain'?: DomainRestApiView;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'networkClass'?: DeviceRestApiViewNetworkClassEnum;
    /**
     * 
     * @type {Set<DeviceGroupRestApiView>}
     * @memberof DeviceRestApiView
     */
    'ownerGroups'?: Set<DeviceGroupRestApiView>;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'serialNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'softwareLevel'?: DeviceRestApiViewSoftwareLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'softwareVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'status'?: DeviceRestApiViewStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof DeviceRestApiView
     */
    'sshPort'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceRestApiView
     */
    'telnetPort'?: number;
    /**
     * 
     * @type {Network4AddressRestApiView}
     * @memberof DeviceRestApiView
     */
    'connectAddress'?: Network4AddressRestApiView;
    /**
     * 
     * @type {Array<number>}
     * @memberof DeviceRestApiView
     */
    'credentialSetIds'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof DeviceRestApiView
     */
    'realDeviceType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceRestApiView
     */
    'endOfLife'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceRestApiView
     */
    'endOfSale'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceRestApiView
     */
    'compliant'?: boolean;
}

export const DeviceRestApiViewNetworkClassEnum = {
    Firewall: 'FIREWALL',
    Loadbalancer: 'LOADBALANCER',
    Router: 'ROUTER',
    Server: 'SERVER',
    Switch: 'SWITCH',
    Switchrouter: 'SWITCHROUTER',
    Accesspoint: 'ACCESSPOINT',
    Wirelesscontroller: 'WIRELESSCONTROLLER',
    Consoleserver: 'CONSOLESERVER',
    Unknown: 'UNKNOWN'
} as const;

export type DeviceRestApiViewNetworkClassEnum = typeof DeviceRestApiViewNetworkClassEnum[keyof typeof DeviceRestApiViewNetworkClassEnum];
export const DeviceRestApiViewSoftwareLevelEnum = {
    Gold: 'GOLD',
    Silver: 'SILVER',
    Bronze: 'BRONZE',
    Unknown: 'UNKNOWN'
} as const;

export type DeviceRestApiViewSoftwareLevelEnum = typeof DeviceRestApiViewSoftwareLevelEnum[keyof typeof DeviceRestApiViewSoftwareLevelEnum];
export const DeviceRestApiViewStatusEnum = {
    Disabled: 'DISABLED',
    Inproduction: 'INPRODUCTION',
    Preproduction: 'PREPRODUCTION'
} as const;

export type DeviceRestApiViewStatusEnum = typeof DeviceRestApiViewStatusEnum[keyof typeof DeviceRestApiViewStatusEnum];

/**
 * 
 * @export
 * @interface DeviceSnmpv1Community
 */
export interface DeviceSnmpv1Community extends DeviceCredentialSet {
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv1Community
     */
    'community'?: string;
}
/**
 * 
 * @export
 * @interface DeviceSnmpv1CommunityAllOf
 */
export interface DeviceSnmpv1CommunityAllOf {
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv1CommunityAllOf
     */
    'community'?: string;
}
/**
 * 
 * @export
 * @interface DeviceSnmpv2cCommunity
 */
export interface DeviceSnmpv2cCommunity extends DeviceCredentialSet {
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv2cCommunity
     */
    'community'?: string;
}
/**
 * 
 * @export
 * @interface DeviceSnmpv3Community
 */
export interface DeviceSnmpv3Community extends DeviceCredentialSet {
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv3Community
     */
    'community'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv3Community
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv3Community
     */
    'authType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv3Community
     */
    'authKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv3Community
     */
    'privType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv3Community
     */
    'privKey'?: string;
}
/**
 * 
 * @export
 * @interface DeviceSnmpv3CommunityAllOf
 */
export interface DeviceSnmpv3CommunityAllOf {
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv3CommunityAllOf
     */
    'community'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv3CommunityAllOf
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv3CommunityAllOf
     */
    'authType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv3CommunityAllOf
     */
    'authKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv3CommunityAllOf
     */
    'privType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSnmpv3CommunityAllOf
     */
    'privKey'?: string;
}
/**
 * 
 * @export
 * @interface DeviceSshAccount
 */
export interface DeviceSshAccount extends DeviceCredentialSet {
    /**
     * 
     * @type {string}
     * @memberof DeviceSshAccount
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSshAccount
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSshAccount
     */
    'superPassword'?: string;
}
/**
 * 
 * @export
 * @interface DeviceSshAccountAllOf
 */
export interface DeviceSshAccountAllOf {
    /**
     * 
     * @type {string}
     * @memberof DeviceSshAccountAllOf
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSshAccountAllOf
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSshAccountAllOf
     */
    'superPassword'?: string;
}
/**
 * 
 * @export
 * @interface DeviceSshKeyAccount
 */
export interface DeviceSshKeyAccount extends DeviceCredentialSet {
    /**
     * 
     * @type {string}
     * @memberof DeviceSshKeyAccount
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSshKeyAccount
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSshKeyAccount
     */
    'superPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSshKeyAccount
     */
    'publicKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSshKeyAccount
     */
    'privateKey'?: string;
}
/**
 * 
 * @export
 * @interface DeviceSshKeyAccountAllOf
 */
export interface DeviceSshKeyAccountAllOf {
    /**
     * 
     * @type {string}
     * @memberof DeviceSshKeyAccountAllOf
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSshKeyAccountAllOf
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSshKeyAccountAllOf
     */
    'superPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSshKeyAccountAllOf
     */
    'publicKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSshKeyAccountAllOf
     */
    'privateKey'?: string;
}
/**
 * 
 * @export
 * @interface DeviceTelnetAccount
 */
export interface DeviceTelnetAccount extends DeviceCredentialSet {
    /**
     * 
     * @type {string}
     * @memberof DeviceTelnetAccount
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTelnetAccount
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTelnetAccount
     */
    'superPassword'?: string;
}
/**
 * 
 * @export
 * @interface DeviceTextAttribute
 */
export interface DeviceTextAttribute extends DeviceAttribute {
    /**
     * 
     * @type {string}
     * @memberof DeviceTextAttribute
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface DeviceTextAttributeAllOf
 */
export interface DeviceTextAttributeAllOf {
    /**
     * 
     * @type {string}
     * @memberof DeviceTextAttributeAllOf
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface DiagnosticBinaryResult
 */
export interface DiagnosticBinaryResult extends DiagnosticResultRestApiView {
    /**
     * 
     * @type {boolean}
     * @memberof DiagnosticBinaryResult
     */
    'assumption'?: boolean;
}
/**
 * 
 * @export
 * @interface DiagnosticLongTextResult
 */
export interface DiagnosticLongTextResult extends DiagnosticResultRestApiView {
}
/**
 * 
 * @export
 * @interface DiagnosticNumericResult
 */
export interface DiagnosticNumericResult extends DiagnosticResultRestApiView {
    /**
     * 
     * @type {number}
     * @memberof DiagnosticNumericResult
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface DiagnosticRestApiView
 */
export interface DiagnosticRestApiView {
    /**
     * 
     * @type {number}
     * @memberof DiagnosticRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DiagnosticRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {DeviceGroupRestApiView}
     * @memberof DiagnosticRestApiView
     */
    'targetGroup'?: DeviceGroupRestApiView;
    /**
     * 
     * @type {boolean}
     * @memberof DiagnosticRestApiView
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DiagnosticRestApiView
     */
    'resultType'?: DiagnosticRestApiViewResultTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DiagnosticRestApiView
     */
    'type': string;
}

export const DiagnosticRestApiViewResultTypeEnum = {
    Numeric: 'NUMERIC',
    Text: 'TEXT',
    Longtext: 'LONGTEXT',
    Date: 'DATE',
    Binary: 'BINARY',
    Binaryfile: 'BINARYFILE'
} as const;

export type DiagnosticRestApiViewResultTypeEnum = typeof DiagnosticRestApiViewResultTypeEnum[keyof typeof DiagnosticRestApiViewResultTypeEnum];

/**
 * 
 * @export
 * @interface DiagnosticResultRestApiView
 */
export interface DiagnosticResultRestApiView {
    /**
     * 
     * @type {string}
     * @memberof DiagnosticResultRestApiView
     */
    'creationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnosticResultRestApiView
     */
    'lastCheckDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnosticResultRestApiView
     */
    'diagnosticName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiagnosticResultRestApiView
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface DiagnosticTextResult
 */
export interface DiagnosticTextResult extends DiagnosticResultRestApiView {
    /**
     * 
     * @type {string}
     * @memberof DiagnosticTextResult
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface DiscoverDeviceTypeTask
 */
export interface DiscoverDeviceTypeTask extends TaskRestApiView {
    /**
     * 
     * @type {Network4Address}
     * @memberof DiscoverDeviceTypeTask
     */
    'deviceAddress'?: Network4Address;
    /**
     * 
     * @type {Device}
     * @memberof DiscoverDeviceTypeTask
     */
    'device'?: Device;
    /**
     * 
     * @type {number}
     * @memberof DiscoverDeviceTypeTask
     */
    'snapshotTaskId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DiscoverDeviceTypeTask
     */
    'discoveredDeviceTypeDescription'?: string;
    /**
     * 
     * @type {number}
     * @memberof DiscoverDeviceTypeTask
     */
    'deviceId'?: number;
}


/**
 * 
 * @export
 * @interface DiscoverDeviceTypeTaskAllOf
 */
export interface DiscoverDeviceTypeTaskAllOf {
    /**
     * 
     * @type {Network4Address}
     * @memberof DiscoverDeviceTypeTaskAllOf
     */
    'deviceAddress'?: Network4Address;
    /**
     * 
     * @type {Device}
     * @memberof DiscoverDeviceTypeTaskAllOf
     */
    'device'?: Device;
    /**
     * 
     * @type {number}
     * @memberof DiscoverDeviceTypeTaskAllOf
     */
    'snapshotTaskId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DiscoverDeviceTypeTaskAllOf
     */
    'discoveredDeviceTypeDescription'?: string;
    /**
     * 
     * @type {number}
     * @memberof DiscoverDeviceTypeTaskAllOf
     */
    'deviceId'?: number;
}
/**
 * 
 * @export
 * @interface Domain
 */
export interface Domain {
    /**
     * 
     * @type {number}
     * @memberof Domain
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    'changeDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    'description'?: string;
    /**
     * 
     * @type {Network4Address}
     * @memberof Domain
     */
    'server4Address'?: Network4Address;
    /**
     * 
     * @type {Network6Address}
     * @memberof Domain
     */
    'server6Address'?: Network6Address;
}
/**
 * 
 * @export
 * @interface DomainRestApiView
 */
export interface DomainRestApiView {
    /**
     * 
     * @type {number}
     * @memberof DomainRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DomainRestApiView
     */
    'changeDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainRestApiView
     */
    'description'?: string;
    /**
     * 
     * @type {Network4AddressRestApiView}
     * @memberof DomainRestApiView
     */
    'server4Address'?: Network4AddressRestApiView;
    /**
     * 
     * @type {Network6AddressRestApiView}
     * @memberof DomainRestApiView
     */
    'server6Address'?: Network6AddressRestApiView;
}
/**
 * 
 * @export
 * @interface DynamicDeviceGroup
 */
export interface DynamicDeviceGroup extends DeviceGroup {
    /**
     * 
     * @type {string}
     * @memberof DynamicDeviceGroup
     */
    'driver'?: string;
    /**
     * 
     * @type {string}
     * @memberof DynamicDeviceGroup
     */
    'query'?: string;
}
/**
 * 
 * @export
 * @interface DynamicDeviceGroupAllOf
 */
export interface DynamicDeviceGroupAllOf {
    /**
     * 
     * @type {string}
     * @memberof DynamicDeviceGroupAllOf
     */
    'driver'?: string;
    /**
     * 
     * @type {string}
     * @memberof DynamicDeviceGroupAllOf
     */
    'query'?: string;
}
/**
 * 
 * @export
 * @interface HardwareRuleRestApiView
 */
export interface HardwareRuleRestApiView {
    /**
     * 
     * @type {number}
     * @memberof HardwareRuleRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HardwareRuleRestApiView
     */
    'driver'?: string;
    /**
     * 
     * @type {DeviceGroupRestApiView}
     * @memberof HardwareRuleRestApiView
     */
    'targetGroup'?: DeviceGroupRestApiView;
    /**
     * 
     * @type {string}
     * @memberof HardwareRuleRestApiView
     */
    'family'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HardwareRuleRestApiView
     */
    'familyRegExp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HardwareRuleRestApiView
     */
    'partNumber'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HardwareRuleRestApiView
     */
    'partNumberRegExp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HardwareRuleRestApiView
     */
    'endOfSale'?: string;
    /**
     * 
     * @type {string}
     * @memberof HardwareRuleRestApiView
     */
    'endOfLife'?: string;
    /**
     * 
     * @type {string}
     * @memberof HardwareRuleRestApiView
     */
    'deviceType'?: string;
}
/**
 * 
 * @export
 * @interface HookRestApiView
 */
export interface HookRestApiView {
    /**
     * 
     * @type {number}
     * @memberof HookRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HookRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HookRestApiView
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Set<HookTriggerRestApiView>}
     * @memberof HookRestApiView
     */
    'triggers'?: Set<HookTriggerRestApiView>;
    /**
     * 
     * @type {string}
     * @memberof HookRestApiView
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface HookTriggerRestApiView
 */
export interface HookTriggerRestApiView {
    /**
     * 
     * @type {string}
     * @memberof HookTriggerRestApiView
     */
    'type'?: HookTriggerRestApiViewTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof HookTriggerRestApiView
     */
    'item'?: string;
}

export const HookTriggerRestApiViewTypeEnum = {
    PostTask: 'POST_TASK'
} as const;

export type HookTriggerRestApiViewTypeEnum = typeof HookTriggerRestApiViewTypeEnum[keyof typeof HookTriggerRestApiViewTypeEnum];

/**
 * 
 * @export
 * @interface LineWithPositionRestApiView
 */
export interface LineWithPositionRestApiView {
    /**
     * 
     * @type {string}
     * @memberof LineWithPositionRestApiView
     */
    'line'?: string;
    /**
     * 
     * @type {number}
     * @memberof LineWithPositionRestApiView
     */
    'position'?: number;
}
/**
 * 
 * @export
 * @interface LocationRestApiView
 */
export interface LocationRestApiView {
    /**
     * 
     * @type {string}
     * @memberof LocationRestApiView
     */
    'type'?: LocationRestApiViewTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof LocationRestApiView
     */
    'fileName'?: string;
}

export const LocationRestApiViewTypeEnum = {
    Embedded: 'EMBEDDED',
    File: 'FILE'
} as const;

export type LocationRestApiViewTypeEnum = typeof LocationRestApiViewTypeEnum[keyof typeof LocationRestApiViewTypeEnum];

/**
 * 
 * @export
 * @interface Module
 */
export interface Module {
    /**
     * 
     * @type {number}
     * @memberof Module
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    'slot'?: string;
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    'partNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    'serialNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    'firstSeenDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    'lastSeenDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Module
     */
    'removed'?: boolean;
}
/**
 * 
 * @export
 * @interface ModuleRestApiView
 */
export interface ModuleRestApiView {
    /**
     * 
     * @type {number}
     * @memberof ModuleRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModuleRestApiView
     */
    'slot'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleRestApiView
     */
    'partNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleRestApiView
     */
    'serialNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleRestApiView
     */
    'firstSeenDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleRestApiView
     */
    'lastSeenDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModuleRestApiView
     */
    'removed'?: boolean;
}
/**
 * 
 * @export
 * @interface Network4Address
 */
export interface Network4Address {
    /**
     * 
     * @type {number}
     * @memberof Network4Address
     */
    'prefixLength'?: number;
    /**
     * 
     * @type {string}
     * @memberof Network4Address
     */
    'addressUsage'?: Network4AddressAddressUsageEnum;
    /**
     * 
     * @type {string}
     * @memberof Network4Address
     */
    'ip'?: string;
}

export const Network4AddressAddressUsageEnum = {
    Primary: 'PRIMARY',
    Secondary: 'SECONDARY',
    Vrrp: 'VRRP',
    Hsrp: 'HSRP',
    Secondaryvrrp: 'SECONDARYVRRP',
    Secondaryhsrp: 'SECONDARYHSRP'
} as const;

export type Network4AddressAddressUsageEnum = typeof Network4AddressAddressUsageEnum[keyof typeof Network4AddressAddressUsageEnum];

/**
 * 
 * @export
 * @interface Network4AddressRestApiView
 */
export interface Network4AddressRestApiView {
    /**
     * 
     * @type {number}
     * @memberof Network4AddressRestApiView
     */
    'prefixLength'?: number;
    /**
     * 
     * @type {string}
     * @memberof Network4AddressRestApiView
     */
    'addressUsage'?: Network4AddressRestApiViewAddressUsageEnum;
    /**
     * 
     * @type {string}
     * @memberof Network4AddressRestApiView
     */
    'ip'?: string;
}

export const Network4AddressRestApiViewAddressUsageEnum = {
    Primary: 'PRIMARY',
    Secondary: 'SECONDARY',
    Vrrp: 'VRRP',
    Hsrp: 'HSRP',
    Secondaryvrrp: 'SECONDARYVRRP',
    Secondaryhsrp: 'SECONDARYHSRP'
} as const;

export type Network4AddressRestApiViewAddressUsageEnum = typeof Network4AddressRestApiViewAddressUsageEnum[keyof typeof Network4AddressRestApiViewAddressUsageEnum];

/**
 * 
 * @export
 * @interface Network6Address
 */
export interface Network6Address {
    /**
     * 
     * @type {number}
     * @memberof Network6Address
     */
    'prefixLength'?: number;
    /**
     * 
     * @type {string}
     * @memberof Network6Address
     */
    'addressUsage'?: Network6AddressAddressUsageEnum;
    /**
     * 
     * @type {string}
     * @memberof Network6Address
     */
    'ip'?: string;
}

export const Network6AddressAddressUsageEnum = {
    Primary: 'PRIMARY',
    Secondary: 'SECONDARY',
    Vrrp: 'VRRP',
    Hsrp: 'HSRP',
    Secondaryvrrp: 'SECONDARYVRRP',
    Secondaryhsrp: 'SECONDARYHSRP'
} as const;

export type Network6AddressAddressUsageEnum = typeof Network6AddressAddressUsageEnum[keyof typeof Network6AddressAddressUsageEnum];

/**
 * 
 * @export
 * @interface Network6AddressRestApiView
 */
export interface Network6AddressRestApiView {
    /**
     * 
     * @type {number}
     * @memberof Network6AddressRestApiView
     */
    'prefixLength'?: number;
    /**
     * 
     * @type {string}
     * @memberof Network6AddressRestApiView
     */
    'addressUsage'?: Network6AddressRestApiViewAddressUsageEnum;
    /**
     * 
     * @type {string}
     * @memberof Network6AddressRestApiView
     */
    'ip'?: string;
}

export const Network6AddressRestApiViewAddressUsageEnum = {
    Primary: 'PRIMARY',
    Secondary: 'SECONDARY',
    Vrrp: 'VRRP',
    Hsrp: 'HSRP',
    Secondaryvrrp: 'SECONDARYVRRP',
    Secondaryhsrp: 'SECONDARYHSRP'
} as const;

export type Network6AddressRestApiViewAddressUsageEnum = typeof Network6AddressRestApiViewAddressUsageEnum[keyof typeof Network6AddressRestApiViewAddressUsageEnum];

/**
 * 
 * @export
 * @interface NetworkInterfaceRestApiView
 */
export interface NetworkInterfaceRestApiView {
    /**
     * 
     * @type {number}
     * @memberof NetworkInterfaceRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof NetworkInterfaceRestApiView
     */
    'interfaceName'?: string;
    /**
     * 
     * @type {Set<Network4AddressRestApiView>}
     * @memberof NetworkInterfaceRestApiView
     */
    'ip4Addresses'?: Set<Network4AddressRestApiView>;
    /**
     * 
     * @type {Set<Network6AddressRestApiView>}
     * @memberof NetworkInterfaceRestApiView
     */
    'ip6Addresses'?: Set<Network6AddressRestApiView>;
    /**
     * 
     * @type {string}
     * @memberof NetworkInterfaceRestApiView
     */
    'vrfInstance'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkInterfaceRestApiView
     */
    'virtualDevice'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkInterfaceRestApiView
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkInterfaceRestApiView
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkInterfaceRestApiView
     */
    'level3'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NetworkInterfaceRestApiView
     */
    'macAddress'?: string;
}
/**
 * 
 * @export
 * @interface PolicyRestApiView
 */
export interface PolicyRestApiView {
    /**
     * 
     * @type {number}
     * @memberof PolicyRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PolicyRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {Set<DeviceGroupRestApiView>}
     * @memberof PolicyRestApiView
     */
    'targetGroups'?: Set<DeviceGroupRestApiView>;
}
/**
 * 
 * @export
 * @interface PurgeDatabaseTask
 */
export interface PurgeDatabaseTask extends TaskRestApiView {
    /**
     * 
     * @type {number}
     * @memberof PurgeDatabaseTask
     */
    'days'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurgeDatabaseTask
     */
    'configDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurgeDatabaseTask
     */
    'configSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurgeDatabaseTask
     */
    'configKeepDays'?: number;
}


/**
 * 
 * @export
 * @interface PurgeDatabaseTaskAllOf
 */
export interface PurgeDatabaseTaskAllOf {
    /**
     * 
     * @type {number}
     * @memberof PurgeDatabaseTaskAllOf
     */
    'days'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurgeDatabaseTaskAllOf
     */
    'configDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurgeDatabaseTaskAllOf
     */
    'configSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PurgeDatabaseTaskAllOf
     */
    'configKeepDays'?: number;
}
/**
 * 
 * @export
 * @interface RsApiTokenRestApiView
 */
export interface RsApiTokenRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsApiTokenRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsApiTokenRestApiView
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsApiTokenRestApiView
     */
    'token'?: string;
    /**
     * 
     * @type {number}
     * @memberof RsApiTokenRestApiView
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface RsClusterMasterCheckRestApiView
 */
export interface RsClusterMasterCheckRestApiView {
    /**
     * 
     * @type {boolean}
     * @memberof RsClusterMasterCheckRestApiView
     */
    'clusterEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RsClusterMasterCheckRestApiView
     */
    'master'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RsClusterMasterCheckRestApiView
     */
    'currentMasterId'?: string;
}
/**
 * 
 * @export
 * @interface RsConfigDeltaRestApiView
 */
export interface RsConfigDeltaRestApiView {
    /**
     * 
     * @type {string}
     * @memberof RsConfigDeltaRestApiView
     */
    'item'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsConfigDeltaRestApiView
     */
    'diffType'?: RsConfigDeltaRestApiViewDiffTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof RsConfigDeltaRestApiView
     */
    'originalPosition'?: number;
    /**
     * 
     * @type {number}
     * @memberof RsConfigDeltaRestApiView
     */
    'revisedPosition'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RsConfigDeltaRestApiView
     */
    'originalLines'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RsConfigDeltaRestApiView
     */
    'revisedLines'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RsConfigDeltaRestApiView
     */
    'preContext'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RsConfigDeltaRestApiView
     */
    'postContext'?: Array<string>;
    /**
     * 
     * @type {Array<LineWithPositionRestApiView>}
     * @memberof RsConfigDeltaRestApiView
     */
    'hierarchy'?: Array<LineWithPositionRestApiView>;
}

export const RsConfigDeltaRestApiViewDiffTypeEnum = {
    Change: 'CHANGE',
    Delete: 'DELETE',
    Insert: 'INSERT'
} as const;

export type RsConfigDeltaRestApiViewDiffTypeEnum = typeof RsConfigDeltaRestApiViewDiffTypeEnum[keyof typeof RsConfigDeltaRestApiViewDiffTypeEnum];

/**
 * 
 * @export
 * @interface RsConfigDiffRestApiView
 */
export interface RsConfigDiffRestApiView {
    /**
     * 
     * @type {string}
     * @memberof RsConfigDiffRestApiView
     */
    'originalDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsConfigDiffRestApiView
     */
    'revisedDate'?: string;
    /**
     * 
     * @type {{ [key: string]: Array<RsConfigDeltaRestApiView>; }}
     * @memberof RsConfigDiffRestApiView
     */
    'deltas'?: { [key: string]: Array<RsConfigDeltaRestApiView>; };
}
/**
 * 
 * @export
 * @interface RsDeviceFamilyRestApiView
 */
export interface RsDeviceFamilyRestApiView {
    /**
     * 
     * @type {string}
     * @memberof RsDeviceFamilyRestApiView
     */
    'driver'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceFamilyRestApiView
     */
    'deviceFamily'?: string;
}
/**
 * 
 * @export
 * @interface RsDeviceGroupRestApiView
 */
export interface RsDeviceGroupRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsDeviceGroupRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceGroupRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceGroupRestApiView
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof RsDeviceGroupRestApiView
     */
    'staticDevices'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceGroupRestApiView
     */
    'driver'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceGroupRestApiView
     */
    'query'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceGroupRestApiView
     */
    'folder'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RsDeviceGroupRestApiView
     */
    'hiddenFromReports'?: boolean;
}
/**
 * 
 * @export
 * @interface RsDeviceRestApiView
 */
export interface RsDeviceRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsDeviceRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RsDeviceRestApiView
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceRestApiView
     */
    'comments'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceRestApiView
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceRestApiView
     */
    'connectIpAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceRestApiView
     */
    'sshPort'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceRestApiView
     */
    'telnetPort'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RsDeviceRestApiView
     */
    'autoTryCredentials'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof RsDeviceRestApiView
     */
    'credentialSetIds'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof RsDeviceRestApiView
     */
    'clearCredentialSetIds'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof RsDeviceRestApiView
     */
    'mgmtDomain'?: number;
    /**
     * 
     * @type {DeviceCredentialSetRestApiView}
     * @memberof RsDeviceRestApiView
     */
    'specificCredentialSet'?: DeviceCredentialSetRestApiView;
}
/**
 * 
 * @export
 * @interface RsDeviceRuleRestApiView
 */
export interface RsDeviceRuleRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsDeviceRuleRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceRuleRestApiView
     */
    'ruleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceRuleRestApiView
     */
    'policyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceRuleRestApiView
     */
    'result'?: RsDeviceRuleRestApiViewResultEnum;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceRuleRestApiView
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceRuleRestApiView
     */
    'checkDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDeviceRuleRestApiView
     */
    'expirationDate'?: string;
}

export const RsDeviceRuleRestApiViewResultEnum = {
    Conforming: 'CONFORMING',
    Exempted: 'EXEMPTED',
    Invalidrule: 'INVALIDRULE',
    Disabled: 'DISABLED',
    Nonconforming: 'NONCONFORMING',
    Notapplicable: 'NOTAPPLICABLE'
} as const;

export type RsDeviceRuleRestApiViewResultEnum = typeof RsDeviceRuleRestApiViewResultEnum[keyof typeof RsDeviceRuleRestApiViewResultEnum];

/**
 * 
 * @export
 * @interface RsDiagnosticRestApiView
 */
export interface RsDiagnosticRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsDiagnosticRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsDiagnosticRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof RsDiagnosticRestApiView
     */
    'targetGroup'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RsDiagnosticRestApiView
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RsDiagnosticRestApiView
     */
    'resultType'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDiagnosticRestApiView
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDiagnosticRestApiView
     */
    'script'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDiagnosticRestApiView
     */
    'deviceDriver'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDiagnosticRestApiView
     */
    'cliMode'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDiagnosticRestApiView
     */
    'command'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDiagnosticRestApiView
     */
    'modifierPattern'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDiagnosticRestApiView
     */
    'modifierReplacement'?: string;
}
/**
 * 
 * @export
 * @interface RsDomainRestApiView
 */
export interface RsDomainRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsDomainRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsDomainRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDomainRestApiView
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsDomainRestApiView
     */
    'ipAddress'?: string;
}
/**
 * 
 * @export
 * @interface RsGroupConfigComplianceStatRestApiView
 */
export interface RsGroupConfigComplianceStatRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsGroupConfigComplianceStatRestApiView
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsGroupConfigComplianceStatRestApiView
     */
    'groupName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsGroupConfigComplianceStatRestApiView
     */
    'groupFolder'?: string;
    /**
     * 
     * @type {number}
     * @memberof RsGroupConfigComplianceStatRestApiView
     */
    'compliantDeviceCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RsGroupConfigComplianceStatRestApiView
     */
    'deviceCount'?: number;
}
/**
 * 
 * @export
 * @interface RsGroupSoftwareComplianceStatRestApiView
 */
export interface RsGroupSoftwareComplianceStatRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsGroupSoftwareComplianceStatRestApiView
     */
    'groupId'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsGroupSoftwareComplianceStatRestApiView
     */
    'groupName'?: string;
    /**
     * 
     * @type {number}
     * @memberof RsGroupSoftwareComplianceStatRestApiView
     */
    'goldDeviceCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RsGroupSoftwareComplianceStatRestApiView
     */
    'silverDeviceCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RsGroupSoftwareComplianceStatRestApiView
     */
    'bronzeDeviceCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RsGroupSoftwareComplianceStatRestApiView
     */
    'deviceCount'?: number;
}
/**
 * 
 * @export
 * @interface RsHardwareRuleRestApiView
 */
export interface RsHardwareRuleRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsHardwareRuleRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof RsHardwareRuleRestApiView
     */
    'group'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsHardwareRuleRestApiView
     */
    'driver'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsHardwareRuleRestApiView
     */
    'partNumber'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RsHardwareRuleRestApiView
     */
    'partNumberRegExp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RsHardwareRuleRestApiView
     */
    'family'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RsHardwareRuleRestApiView
     */
    'familyRegExp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RsHardwareRuleRestApiView
     */
    'endOfSale'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsHardwareRuleRestApiView
     */
    'endOfLife'?: string;
}
/**
 * 
 * @export
 * @interface RsHardwareSupportStatRestApiView
 */
export interface RsHardwareSupportStatRestApiView {
    /**
     * 
     * @type {string}
     * @memberof RsHardwareSupportStatRestApiView
     */
    'eoxDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof RsHardwareSupportStatRestApiView
     */
    'deviceCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsHardwareSupportStatRestApiView
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface RsLightAccessFailureDeviceRestApiView
 */
export interface RsLightAccessFailureDeviceRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsLightAccessFailureDeviceRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsLightAccessFailureDeviceRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightAccessFailureDeviceRestApiView
     */
    'family'?: string;
    /**
     * 
     * @type {Network4AddressRestApiView}
     * @memberof RsLightAccessFailureDeviceRestApiView
     */
    'mgmtAddress'?: Network4AddressRestApiView;
    /**
     * 
     * @type {string}
     * @memberof RsLightAccessFailureDeviceRestApiView
     */
    'status'?: RsLightAccessFailureDeviceRestApiViewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof RsLightAccessFailureDeviceRestApiView
     */
    'lastSuccess'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightAccessFailureDeviceRestApiView
     */
    'lastFailure'?: string;
}

export const RsLightAccessFailureDeviceRestApiViewStatusEnum = {
    Disabled: 'DISABLED',
    Inproduction: 'INPRODUCTION',
    Preproduction: 'PREPRODUCTION'
} as const;

export type RsLightAccessFailureDeviceRestApiViewStatusEnum = typeof RsLightAccessFailureDeviceRestApiViewStatusEnum[keyof typeof RsLightAccessFailureDeviceRestApiViewStatusEnum];

/**
 * 
 * @export
 * @interface RsLightConfigRestApiView
 */
export interface RsLightConfigRestApiView {
    /**
     * 
     * @type {string}
     * @memberof RsLightConfigRestApiView
     */
    'deviceName'?: string;
    /**
     * 
     * @type {number}
     * @memberof RsLightConfigRestApiView
     */
    'deviceId'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsLightConfigRestApiView
     */
    'changeDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightConfigRestApiView
     */
    'author'?: string;
    /**
     * 
     * @type {number}
     * @memberof RsLightConfigRestApiView
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface RsLightDeviceRestApiView
 */
export interface RsLightDeviceRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsLightDeviceRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsLightDeviceRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightDeviceRestApiView
     */
    'family'?: string;
    /**
     * 
     * @type {Network4AddressRestApiView}
     * @memberof RsLightDeviceRestApiView
     */
    'mgmtAddress'?: Network4AddressRestApiView;
    /**
     * 
     * @type {string}
     * @memberof RsLightDeviceRestApiView
     */
    'status'?: RsLightDeviceRestApiViewStatusEnum;
}

export const RsLightDeviceRestApiViewStatusEnum = {
    Disabled: 'DISABLED',
    Inproduction: 'INPRODUCTION',
    Preproduction: 'PREPRODUCTION'
} as const;

export type RsLightDeviceRestApiViewStatusEnum = typeof RsLightDeviceRestApiViewStatusEnum[keyof typeof RsLightDeviceRestApiViewStatusEnum];

/**
 * 
 * @export
 * @interface RsLightExemptedDeviceRestApiView
 */
export interface RsLightExemptedDeviceRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsLightExemptedDeviceRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsLightExemptedDeviceRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightExemptedDeviceRestApiView
     */
    'family'?: string;
    /**
     * 
     * @type {Network4AddressRestApiView}
     * @memberof RsLightExemptedDeviceRestApiView
     */
    'mgmtAddress'?: Network4AddressRestApiView;
    /**
     * 
     * @type {string}
     * @memberof RsLightExemptedDeviceRestApiView
     */
    'status'?: RsLightExemptedDeviceRestApiViewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof RsLightExemptedDeviceRestApiView
     */
    'expirationDate'?: string;
}

export const RsLightExemptedDeviceRestApiViewStatusEnum = {
    Disabled: 'DISABLED',
    Inproduction: 'INPRODUCTION',
    Preproduction: 'PREPRODUCTION'
} as const;

export type RsLightExemptedDeviceRestApiViewStatusEnum = typeof RsLightExemptedDeviceRestApiViewStatusEnum[keyof typeof RsLightExemptedDeviceRestApiViewStatusEnum];

/**
 * 
 * @export
 * @interface RsLightPolicyRuleDeviceRestApiView
 */
export interface RsLightPolicyRuleDeviceRestApiView {
    /**
     * 
     * @type {Set<DeviceAttributeRestApiView>}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'attributes'?: Set<DeviceAttributeRestApiView>;
    /**
     * 
     * @type {boolean}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'autoTryCredentials'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'changeDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'comments'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'contact'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'creator'?: string;
    /**
     * 
     * @type {DeviceCredentialSetRestApiView}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'specificCredentialSet'?: DeviceCredentialSetRestApiView;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'driver'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'eolDate'?: string;
    /**
     * 
     * @type {ModuleRestApiView}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'eolModule'?: ModuleRestApiView;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'eosDate'?: string;
    /**
     * 
     * @type {ModuleRestApiView}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'eosModule'?: ModuleRestApiView;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'family'?: string;
    /**
     * 
     * @type {number}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'location'?: string;
    /**
     * 
     * @type {Network4AddressRestApiView}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'mgmtAddress'?: Network4AddressRestApiView;
    /**
     * 
     * @type {DomainRestApiView}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'mgmtDomain'?: DomainRestApiView;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'networkClass'?: RsLightPolicyRuleDeviceRestApiViewNetworkClassEnum;
    /**
     * 
     * @type {Set<DeviceGroupRestApiView>}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'ownerGroups'?: Set<DeviceGroupRestApiView>;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'serialNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'softwareLevel'?: RsLightPolicyRuleDeviceRestApiViewSoftwareLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'softwareVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'status'?: RsLightPolicyRuleDeviceRestApiViewStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'sshPort'?: number;
    /**
     * 
     * @type {number}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'telnetPort'?: number;
    /**
     * 
     * @type {Network4AddressRestApiView}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'connectAddress'?: Network4AddressRestApiView;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'ruleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'policyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'checkDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'result'?: RsLightPolicyRuleDeviceRestApiViewResultEnum;
    /**
     * 
     * @type {Array<number>}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'credentialSetIds'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'realDeviceType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'endOfLife'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'endOfSale'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RsLightPolicyRuleDeviceRestApiView
     */
    'compliant'?: boolean;
}

export const RsLightPolicyRuleDeviceRestApiViewNetworkClassEnum = {
    Firewall: 'FIREWALL',
    Loadbalancer: 'LOADBALANCER',
    Router: 'ROUTER',
    Server: 'SERVER',
    Switch: 'SWITCH',
    Switchrouter: 'SWITCHROUTER',
    Accesspoint: 'ACCESSPOINT',
    Wirelesscontroller: 'WIRELESSCONTROLLER',
    Consoleserver: 'CONSOLESERVER',
    Unknown: 'UNKNOWN'
} as const;

export type RsLightPolicyRuleDeviceRestApiViewNetworkClassEnum = typeof RsLightPolicyRuleDeviceRestApiViewNetworkClassEnum[keyof typeof RsLightPolicyRuleDeviceRestApiViewNetworkClassEnum];
export const RsLightPolicyRuleDeviceRestApiViewSoftwareLevelEnum = {
    Gold: 'GOLD',
    Silver: 'SILVER',
    Bronze: 'BRONZE',
    Unknown: 'UNKNOWN'
} as const;

export type RsLightPolicyRuleDeviceRestApiViewSoftwareLevelEnum = typeof RsLightPolicyRuleDeviceRestApiViewSoftwareLevelEnum[keyof typeof RsLightPolicyRuleDeviceRestApiViewSoftwareLevelEnum];
export const RsLightPolicyRuleDeviceRestApiViewStatusEnum = {
    Disabled: 'DISABLED',
    Inproduction: 'INPRODUCTION',
    Preproduction: 'PREPRODUCTION'
} as const;

export type RsLightPolicyRuleDeviceRestApiViewStatusEnum = typeof RsLightPolicyRuleDeviceRestApiViewStatusEnum[keyof typeof RsLightPolicyRuleDeviceRestApiViewStatusEnum];
export const RsLightPolicyRuleDeviceRestApiViewResultEnum = {
    Conforming: 'CONFORMING',
    Exempted: 'EXEMPTED',
    Invalidrule: 'INVALIDRULE',
    Disabled: 'DISABLED',
    Nonconforming: 'NONCONFORMING',
    Notapplicable: 'NOTAPPLICABLE'
} as const;

export type RsLightPolicyRuleDeviceRestApiViewResultEnum = typeof RsLightPolicyRuleDeviceRestApiViewResultEnum[keyof typeof RsLightPolicyRuleDeviceRestApiViewResultEnum];

/**
 * 
 * @export
 * @interface RsLightSoftwareLevelDeviceRestApiView
 */
export interface RsLightSoftwareLevelDeviceRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsLightSoftwareLevelDeviceRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsLightSoftwareLevelDeviceRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLightSoftwareLevelDeviceRestApiView
     */
    'family'?: string;
    /**
     * 
     * @type {Network4AddressRestApiView}
     * @memberof RsLightSoftwareLevelDeviceRestApiView
     */
    'mgmtAddress'?: Network4AddressRestApiView;
    /**
     * 
     * @type {string}
     * @memberof RsLightSoftwareLevelDeviceRestApiView
     */
    'status'?: RsLightSoftwareLevelDeviceRestApiViewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof RsLightSoftwareLevelDeviceRestApiView
     */
    'softwareLevel'?: RsLightSoftwareLevelDeviceRestApiViewSoftwareLevelEnum;
}

export const RsLightSoftwareLevelDeviceRestApiViewStatusEnum = {
    Disabled: 'DISABLED',
    Inproduction: 'INPRODUCTION',
    Preproduction: 'PREPRODUCTION'
} as const;

export type RsLightSoftwareLevelDeviceRestApiViewStatusEnum = typeof RsLightSoftwareLevelDeviceRestApiViewStatusEnum[keyof typeof RsLightSoftwareLevelDeviceRestApiViewStatusEnum];
export const RsLightSoftwareLevelDeviceRestApiViewSoftwareLevelEnum = {
    Gold: 'GOLD',
    Silver: 'SILVER',
    Bronze: 'BRONZE',
    Unknown: 'UNKNOWN'
} as const;

export type RsLightSoftwareLevelDeviceRestApiViewSoftwareLevelEnum = typeof RsLightSoftwareLevelDeviceRestApiViewSoftwareLevelEnum[keyof typeof RsLightSoftwareLevelDeviceRestApiViewSoftwareLevelEnum];

/**
 * 
 * @export
 * @interface RsLoginRestApiView
 */
export interface RsLoginRestApiView {
    /**
     * 
     * @type {string}
     * @memberof RsLoginRestApiView
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLoginRestApiView
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsLoginRestApiView
     */
    'newPassword'?: string;
}
/**
 * 
 * @export
 * @interface RsNewDeviceRestApiView
 */
export interface RsNewDeviceRestApiView {
    /**
     * 
     * @type {boolean}
     * @memberof RsNewDeviceRestApiView
     */
    'autoDiscover'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RsNewDeviceRestApiView
     */
    'autoDiscoveryTask'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsNewDeviceRestApiView
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {number}
     * @memberof RsNewDeviceRestApiView
     */
    'domainId'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsNewDeviceRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsNewDeviceRestApiView
     */
    'deviceType'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsNewDeviceRestApiView
     */
    'connectIpAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsNewDeviceRestApiView
     */
    'sshPort'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsNewDeviceRestApiView
     */
    'telnetPort'?: string;
    /**
     * 
     * @type {DeviceCredentialSetRestApiView}
     * @memberof RsNewDeviceRestApiView
     */
    'specificCredentialSet'?: DeviceCredentialSetRestApiView;
}
/**
 * 
 * @export
 * @interface RsPartNumberRestApiView
 */
export interface RsPartNumberRestApiView {
    /**
     * 
     * @type {string}
     * @memberof RsPartNumberRestApiView
     */
    'partNumber'?: string;
}
/**
 * 
 * @export
 * @interface RsPolicyRestApiView
 */
export interface RsPolicyRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsPolicyRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsPolicyRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {Set<number>}
     * @memberof RsPolicyRestApiView
     */
    'targetGroups'?: Set<number>;
}
/**
 * 
 * @export
 * @interface RsRuleRestApiView
 */
export interface RsRuleRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsRuleRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsRuleRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsRuleRestApiView
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsRuleRestApiView
     */
    'script'?: string;
    /**
     * 
     * @type {number}
     * @memberof RsRuleRestApiView
     */
    'policy'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RsRuleRestApiView
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RsRuleRestApiView
     */
    'exemptions'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof RsRuleRestApiView
     */
    'text'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RsRuleRestApiView
     */
    'regExp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RsRuleRestApiView
     */
    'context'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsRuleRestApiView
     */
    'driver'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsRuleRestApiView
     */
    'field'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RsRuleRestApiView
     */
    'anyBlock'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RsRuleRestApiView
     */
    'matchAll'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RsRuleRestApiView
     */
    'invert'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RsRuleRestApiView
     */
    'normalize'?: boolean;
}
/**
 * 
 * @export
 * @interface RsRuleTestRestApiView
 */
export interface RsRuleTestRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsRuleTestRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsRuleTestRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsRuleTestRestApiView
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsRuleTestRestApiView
     */
    'script'?: string;
    /**
     * 
     * @type {number}
     * @memberof RsRuleTestRestApiView
     */
    'policy'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RsRuleTestRestApiView
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RsRuleTestRestApiView
     */
    'exemptions'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof RsRuleTestRestApiView
     */
    'text'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RsRuleTestRestApiView
     */
    'regExp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RsRuleTestRestApiView
     */
    'context'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsRuleTestRestApiView
     */
    'driver'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsRuleTestRestApiView
     */
    'field'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RsRuleTestRestApiView
     */
    'anyBlock'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RsRuleTestRestApiView
     */
    'matchAll'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RsRuleTestRestApiView
     */
    'invert'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RsRuleTestRestApiView
     */
    'normalize'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RsRuleTestRestApiView
     */
    'device'?: number;
}
/**
 * 
 * @export
 * @interface RsRuleTestResultRestApiView
 */
export interface RsRuleTestResultRestApiView {
    /**
     * 
     * @type {string}
     * @memberof RsRuleTestResultRestApiView
     */
    'result'?: RsRuleTestResultRestApiViewResultEnum;
    /**
     * 
     * @type {string}
     * @memberof RsRuleTestResultRestApiView
     */
    'scriptError'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsRuleTestResultRestApiView
     */
    'comment'?: string;
}

export const RsRuleTestResultRestApiViewResultEnum = {
    Conforming: 'CONFORMING',
    Exempted: 'EXEMPTED',
    Invalidrule: 'INVALIDRULE',
    Disabled: 'DISABLED',
    Nonconforming: 'NONCONFORMING',
    Notapplicable: 'NOTAPPLICABLE'
} as const;

export type RsRuleTestResultRestApiViewResultEnum = typeof RsRuleTestResultRestApiViewResultEnum[keyof typeof RsRuleTestResultRestApiViewResultEnum];

/**
 * 
 * @export
 * @interface RsSearchCriteriaRestApiView
 */
export interface RsSearchCriteriaRestApiView {
    /**
     * 
     * @type {string}
     * @memberof RsSearchCriteriaRestApiView
     */
    'driver'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsSearchCriteriaRestApiView
     */
    'query'?: string;
}
/**
 * 
 * @export
 * @interface RsSearchResultsRestApiView
 */
export interface RsSearchResultsRestApiView {
    /**
     * 
     * @type {string}
     * @memberof RsSearchResultsRestApiView
     */
    'query'?: string;
    /**
     * 
     * @type {Array<RsLightDeviceRestApiView>}
     * @memberof RsSearchResultsRestApiView
     */
    'devices'?: Array<RsLightDeviceRestApiView>;
}
/**
 * 
 * @export
 * @interface RsServerInfoRestApiView
 */
export interface RsServerInfoRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsServerInfoRestApiView
     */
    'maxIdleTimout'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsServerInfoRestApiView
     */
    'serverVersion'?: string;
}
/**
 * 
 * @export
 * @interface RsSoftwareRuleRestApiView
 */
export interface RsSoftwareRuleRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsSoftwareRuleRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof RsSoftwareRuleRestApiView
     */
    'group'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsSoftwareRuleRestApiView
     */
    'driver'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsSoftwareRuleRestApiView
     */
    'version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RsSoftwareRuleRestApiView
     */
    'versionRegExp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RsSoftwareRuleRestApiView
     */
    'family'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RsSoftwareRuleRestApiView
     */
    'familyRegExp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RsSoftwareRuleRestApiView
     */
    'partNumber'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RsSoftwareRuleRestApiView
     */
    'partNumberRegExp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RsSoftwareRuleRestApiView
     */
    'level'?: RsSoftwareRuleRestApiViewLevelEnum;
    /**
     * 
     * @type {number}
     * @memberof RsSoftwareRuleRestApiView
     */
    'priority'?: number;
}

export const RsSoftwareRuleRestApiViewLevelEnum = {
    Gold: 'GOLD',
    Silver: 'SILVER',
    Bronze: 'BRONZE',
    Unknown: 'UNKNOWN'
} as const;

export type RsSoftwareRuleRestApiViewLevelEnum = typeof RsSoftwareRuleRestApiViewLevelEnum[keyof typeof RsSoftwareRuleRestApiViewLevelEnum];

/**
 * 
 * @export
 * @interface RsTaskRestApiView
 */
export interface RsTaskRestApiView {
    /**
     * Task unique ID
     * @type {number}
     * @memberof RsTaskRestApiView
     */
    'id'?: number;
    /**
     * Set to cancel the task
     * @type {boolean}
     * @memberof RsTaskRestApiView
     */
    'cancelled'?: boolean;
    /**
     * Type of task
     * @type {string}
     * @memberof RsTaskRestApiView
     */
    'type'?: string;
    /**
     * The group ID for group-based task
     * @type {number}
     * @memberof RsTaskRestApiView
     */
    'group'?: number;
    /**
     * The device ID for device-based task
     * @type {number}
     * @memberof RsTaskRestApiView
     */
    'device'?: number;
    /**
     * The domain ID when applicable
     * @type {number}
     * @memberof RsTaskRestApiView
     */
    'domain'?: number;
    /**
     * Subnets to scan (comma, space or new line separated)
     * @type {string}
     * @memberof RsTaskRestApiView
     */
    'subnets'?: string;
    /**
     * Scheduling reference date for scheduled task
     * @type {string}
     * @memberof RsTaskRestApiView
     */
    'scheduleReference'?: string;
    /**
     * Scheduling mode (ASAP, once, recurring...)
     * @type {string}
     * @memberof RsTaskRestApiView
     */
    'scheduleType'?: RsTaskRestApiViewScheduleTypeEnum;
    /**
     * Scheduling factor for recurring task
     * @type {number}
     * @memberof RsTaskRestApiView
     */
    'scheduleFactor'?: number;
    /**
     * Task comment
     * @type {string}
     * @memberof RsTaskRestApiView
     */
    'comments'?: string;
    /**
     * Ignore devices that had a successful snapshot in the last given hours
     * @type {number}
     * @memberof RsTaskRestApiView
     */
    'limitToOutofdateDeviceHours'?: number;
    /**
     * Purge tasks older than this number of days
     * @type {number}
     * @memberof RsTaskRestApiView
     */
    'daysToPurge'?: number;
    /**
     * Purge configurations older than this number of days
     * @type {number}
     * @memberof RsTaskRestApiView
     */
    'configDaysToPurge'?: number;
    /**
     * Purge configurations bigger than this size (KB)
     * @type {number}
     * @memberof RsTaskRestApiView
     */
    'configSizeToPurge'?: number;
    /**
     * When purging old configurations, keep a configuration every n days
     * @type {number}
     * @memberof RsTaskRestApiView
     */
    'configKeepDays'?: number;
    /**
     * The script to execute
     * @type {string}
     * @memberof RsTaskRestApiView
     */
    'script'?: string;
    /**
     * The device driver to use
     * @type {string}
     * @memberof RsTaskRestApiView
     */
    'driver'?: string;
    /**
     * Enable task debugging
     * @type {boolean}
     * @memberof RsTaskRestApiView
     */
    'debugEnabled'?: boolean;
    /**
     * Disable automatic diagnostic task (applies to snapshot tasks)
     * @type {boolean}
     * @memberof RsTaskRestApiView
     */
    'dontRunDiagnostics'?: boolean;
    /**
     * Disable automatic check compliance task (applies to snapshot and diagnostic tasks)
     * @type {boolean}
     * @memberof RsTaskRestApiView
     */
    'dontCheckCompliance'?: boolean;
}

export const RsTaskRestApiViewScheduleTypeEnum = {
    Asap: 'ASAP',
    At: 'AT',
    Daily: 'DAILY',
    Monthly: 'MONTHLY',
    Weekly: 'WEEKLY',
    Hourly: 'HOURLY'
} as const;

export type RsTaskRestApiViewScheduleTypeEnum = typeof RsTaskRestApiViewScheduleTypeEnum[keyof typeof RsTaskRestApiViewScheduleTypeEnum];

/**
 * 
 * @export
 * @interface RsTaskSummaryRestApiView
 */
export interface RsTaskSummaryRestApiView {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof RsTaskSummaryRestApiView
     */
    'countByStatus'?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof RsTaskSummaryRestApiView
     */
    'threadCount'?: number;
}
/**
 * 
 * @export
 * @interface RsUserRestApiView
 */
export interface RsUserRestApiView {
    /**
     * 
     * @type {number}
     * @memberof RsUserRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RsUserRestApiView
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof RsUserRestApiView
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof RsUserRestApiView
     */
    'level'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RsUserRestApiView
     */
    'local'?: boolean;
}
/**
 * 
 * @export
 * @interface RuleRestApiView
 */
export interface RuleRestApiView {
    /**
     * 
     * @type {boolean}
     * @memberof RuleRestApiView
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RuleRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RuleRestApiView
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleRestApiView
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface RunDeviceGroupScriptTask
 */
export interface RunDeviceGroupScriptTask extends TaskRestApiView {
}


/**
 * 
 * @export
 * @interface RunDeviceScriptTask
 */
export interface RunDeviceScriptTask extends TaskRestApiView {
}


/**
 * 
 * @export
 * @interface RunDiagnosticsTask
 */
export interface RunDiagnosticsTask extends TaskRestApiView {
    /**
     * 
     * @type {boolean}
     * @memberof RunDiagnosticsTask
     */
    'dontCheckCompliance'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RunDiagnosticsTask
     */
    'deviceId'?: number;
}


/**
 * 
 * @export
 * @interface RunDiagnosticsTaskAllOf
 */
export interface RunDiagnosticsTaskAllOf {
    /**
     * 
     * @type {boolean}
     * @memberof RunDiagnosticsTaskAllOf
     */
    'dontCheckCompliance'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RunDiagnosticsTaskAllOf
     */
    'deviceId'?: number;
}
/**
 * 
 * @export
 * @interface RunGroupDiagnosticsTask
 */
export interface RunGroupDiagnosticsTask extends TaskRestApiView {
    /**
     * 
     * @type {boolean}
     * @memberof RunGroupDiagnosticsTask
     */
    'dontCheckCompliance'?: boolean;
}


/**
 * 
 * @export
 * @interface RunGroupDiagnosticsTaskAllOf
 */
export interface RunGroupDiagnosticsTaskAllOf {
    /**
     * 
     * @type {boolean}
     * @memberof RunGroupDiagnosticsTaskAllOf
     */
    'dontCheckCompliance'?: boolean;
}
/**
 * 
 * @export
 * @interface ScanSubnetsTask
 */
export interface ScanSubnetsTask extends TaskRestApiView {
}


/**
 * 
 * @export
 * @interface SoftwareRuleRestApiView
 */
export interface SoftwareRuleRestApiView {
    /**
     * 
     * @type {number}
     * @memberof SoftwareRuleRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof SoftwareRuleRestApiView
     */
    'priority'?: number;
    /**
     * 
     * @type {DeviceGroupRestApiView}
     * @memberof SoftwareRuleRestApiView
     */
    'targetGroup'?: DeviceGroupRestApiView;
    /**
     * 
     * @type {string}
     * @memberof SoftwareRuleRestApiView
     */
    'driver'?: string;
    /**
     * 
     * @type {string}
     * @memberof SoftwareRuleRestApiView
     */
    'family'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SoftwareRuleRestApiView
     */
    'familyRegExp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SoftwareRuleRestApiView
     */
    'version'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SoftwareRuleRestApiView
     */
    'versionRegExp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SoftwareRuleRestApiView
     */
    'partNumber'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SoftwareRuleRestApiView
     */
    'partNumberRegExp'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SoftwareRuleRestApiView
     */
    'level'?: SoftwareRuleRestApiViewLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof SoftwareRuleRestApiView
     */
    'deviceType'?: string;
}

export const SoftwareRuleRestApiViewLevelEnum = {
    Gold: 'GOLD',
    Silver: 'SILVER',
    Bronze: 'BRONZE',
    Unknown: 'UNKNOWN'
} as const;

export type SoftwareRuleRestApiViewLevelEnum = typeof SoftwareRuleRestApiViewLevelEnum[keyof typeof SoftwareRuleRestApiViewLevelEnum];

/**
 * 
 * @export
 * @interface SshConfigRestApiView
 */
export interface SshConfigRestApiView {
    /**
     * 
     * @type {Array<string>}
     * @memberof SshConfigRestApiView
     */
    'kexAlgorithms'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SshConfigRestApiView
     */
    'hostKeyAlgorithms'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SshConfigRestApiView
     */
    'ciphers'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SshConfigRestApiView
     */
    'macs'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof SshConfigRestApiView
     */
    'usePty'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SshConfigRestApiView
     */
    'terminalType'?: string;
    /**
     * 
     * @type {number}
     * @memberof SshConfigRestApiView
     */
    'terminalCols'?: number;
    /**
     * 
     * @type {number}
     * @memberof SshConfigRestApiView
     */
    'terminalRows'?: number;
    /**
     * 
     * @type {number}
     * @memberof SshConfigRestApiView
     */
    'terminalHeight'?: number;
    /**
     * 
     * @type {number}
     * @memberof SshConfigRestApiView
     */
    'terminalWidth'?: number;
}
/**
 * 
 * @export
 * @interface StaticDeviceGroup
 */
export interface StaticDeviceGroup extends DeviceGroup {
}
/**
 * 
 * @export
 * @interface TakeGroupSnapshotTask
 */
export interface TakeGroupSnapshotTask extends TaskRestApiView {
    /**
     * 
     * @type {boolean}
     * @memberof TakeGroupSnapshotTask
     */
    'dontRunDiagnostics'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TakeGroupSnapshotTask
     */
    'dontCheckCompliance'?: boolean;
}


/**
 * 
 * @export
 * @interface TakeGroupSnapshotTaskAllOf
 */
export interface TakeGroupSnapshotTaskAllOf {
    /**
     * 
     * @type {boolean}
     * @memberof TakeGroupSnapshotTaskAllOf
     */
    'dontRunDiagnostics'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TakeGroupSnapshotTaskAllOf
     */
    'dontCheckCompliance'?: boolean;
}
/**
 * 
 * @export
 * @interface TakeSnapshotTask
 */
export interface TakeSnapshotTask extends TaskRestApiView {
    /**
     * 
     * @type {Device}
     * @memberof TakeSnapshotTask
     */
    'device'?: Device;
    /**
     * 
     * @type {boolean}
     * @memberof TakeSnapshotTask
     */
    'automatic'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TakeSnapshotTask
     */
    'dontRunDiagnostics'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TakeSnapshotTask
     */
    'dontCheckCompliance'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TakeSnapshotTask
     */
    'deviceId'?: number;
}


/**
 * 
 * @export
 * @interface TakeSnapshotTaskAllOf
 */
export interface TakeSnapshotTaskAllOf {
    /**
     * 
     * @type {Device}
     * @memberof TakeSnapshotTaskAllOf
     */
    'device'?: Device;
    /**
     * 
     * @type {boolean}
     * @memberof TakeSnapshotTaskAllOf
     */
    'automatic'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TakeSnapshotTaskAllOf
     */
    'dontRunDiagnostics'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TakeSnapshotTaskAllOf
     */
    'dontCheckCompliance'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TakeSnapshotTaskAllOf
     */
    'deviceId'?: number;
}
/**
 * 
 * @export
 * @interface TaskRestApiView
 */
export interface TaskRestApiView {
    /**
     * 
     * @type {string}
     * @memberof TaskRestApiView
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskRestApiView
     */
    'changeDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskRestApiView
     */
    'comments'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskRestApiView
     */
    'creationDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TaskRestApiView
     */
    'debugEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TaskRestApiView
     */
    'executionDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {TaskRestApiViewLogs}
     * @memberof TaskRestApiView
     */
    'logs'?: TaskRestApiViewLogs;
    /**
     * 
     * @type {string}
     * @memberof TaskRestApiView
     */
    'scheduleReference'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskRestApiView
     */
    'scheduleType'?: TaskRestApiViewScheduleTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TaskRestApiView
     */
    'scheduleFactor'?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskRestApiView
     */
    'status'?: TaskRestApiViewStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TaskRestApiView
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskRestApiView
     */
    'runnerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskRestApiView
     */
    'nextExecutionDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskRestApiView
     */
    'taskDescription'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TaskRestApiView
     */
    'repeating'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TaskRestApiView
     */
    'type': string;
}

export const TaskRestApiViewScheduleTypeEnum = {
    Asap: 'ASAP',
    At: 'AT',
    Daily: 'DAILY',
    Monthly: 'MONTHLY',
    Weekly: 'WEEKLY',
    Hourly: 'HOURLY'
} as const;

export type TaskRestApiViewScheduleTypeEnum = typeof TaskRestApiViewScheduleTypeEnum[keyof typeof TaskRestApiViewScheduleTypeEnum];
export const TaskRestApiViewStatusEnum = {
    Cancelled: 'CANCELLED',
    Failure: 'FAILURE',
    New: 'NEW',
    Running: 'RUNNING',
    Scheduled: 'SCHEDULED',
    Success: 'SUCCESS',
    Waiting: 'WAITING'
} as const;

export type TaskRestApiViewStatusEnum = typeof TaskRestApiViewStatusEnum[keyof typeof TaskRestApiViewStatusEnum];

/**
 * 
 * @export
 * @interface TaskRestApiViewLogs
 */
export interface TaskRestApiViewLogs {
    /**
     * 
     * @type {number}
     * @memberof TaskRestApiViewLogs
     */
    'length'?: number;
}
/**
 * 
 * @export
 * @interface TelnetConfigRestApiView
 */
export interface TelnetConfigRestApiView {
    /**
     * 
     * @type {string}
     * @memberof TelnetConfigRestApiView
     */
    'terminalType'?: string;
}
/**
 * 
 * @export
 * @interface UiUserRestApiView
 */
export interface UiUserRestApiView {
    /**
     * 
     * @type {number}
     * @memberof UiUserRestApiView
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UiUserRestApiView
     */
    'local'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UiUserRestApiView
     */
    'username'?: string;
    /**
     * 
     * @type {number}
     * @memberof UiUserRestApiView
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface WebHook
 */
export interface WebHook extends HookRestApiView {
    /**
     * 
     * @type {string}
     * @memberof WebHook
     */
    'action'?: WebHookActionEnum;
    /**
     * 
     * @type {string}
     * @memberof WebHook
     */
    'url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WebHook
     */
    'sslValidation'?: boolean;
}

export const WebHookActionEnum = {
    Xml: 'POST_XML',
    Json: 'POST_JSON'
} as const;

export type WebHookActionEnum = typeof WebHookActionEnum[keyof typeof WebHookActionEnum];

/**
 * 
 * @export
 * @interface WebHookAllOf
 */
export interface WebHookAllOf {
    /**
     * 
     * @type {string}
     * @memberof WebHookAllOf
     */
    'action'?: WebHookAllOfActionEnum;
    /**
     * 
     * @type {string}
     * @memberof WebHookAllOf
     */
    'url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WebHookAllOf
     */
    'sslValidation'?: boolean;
}

export const WebHookAllOfActionEnum = {
    Xml: 'POST_XML',
    Json: 'POST_JSON'
} as const;

export type WebHookAllOfActionEnum = typeof WebHookAllOfActionEnum[keyof typeof WebHookAllOfActionEnum];


/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new API token.
         * @summary Add a new API token
         * @param {RsApiTokenRestApiView} [rsApiTokenRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addApiToken: async (rsApiTokenRestApiView?: RsApiTokenRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/apitokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsApiTokenRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a credential set, which then can be used to authenticate against the devices.
         * @summary Add a credential set
         * @param {DeviceCredentialSetRestApiView} [deviceCredentialSetRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredentialSet: async (deviceCredentialSetRestApiView?: DeviceCredentialSetRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/credentialsets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceCredentialSetRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a device domain.
         * @summary Add a device domain
         * @param {RsDomainRestApiView} [rsDomainRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDomain: async (rsDomainRestApiView?: RsDomainRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsDomainRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a hook. Based on given criteria, Netshot will run the given action when specific events occur.
         * @summary Add a hook
         * @param {HookRestApiView} [hookRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHook: async (hookRestApiView?: HookRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hookRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Netshot user.
         * @summary Add a user to Netshot
         * @param {RsUserRestApiView} [rsUserRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser: async (rsUserRestApiView?: RsUserRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsUserRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an API token, by ID.
         * @summary Remove an API token
         * @param {number} id Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiToken: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteApiToken', 'id', id)
            const localVarPath = `/apitokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the given credential set, by ID.
         * @summary Remove a credential set
         * @param {number} id Credential set ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredentialSet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCredentialSet', 'id', id)
            const localVarPath = `/credentialsets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the given device domain, by ID.
         * @summary Remove a device domain
         * @param {number} id Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDomain', 'id', id)
            const localVarPath = `/domains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the hook, by ID.
         * @summary Remove a hook
         * @param {number} id Hook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHook: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteHook', 'id', id)
            const localVarPath = `/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a user from the Netshot database.
         * @summary Remove a Netshot user.
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of API tokens.
         * @summary Get the API tokens
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiTokens: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/apitokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns cluster mastership info of the current node. Might be used by local-balancer to redirect http to the proper server (return code 205 means the local server is not master).
         * @summary Check if local server is cluster master
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterMasterStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cluster/masterstatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the members of the Netshot high availability cluster (empty list if clustering is not enabled).
         * @summary Get cluster members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterMembers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cluster/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of global credential sets (SSH, SNMP, etc. accounts) for authentication against the devices.
         * @summary Get the global credential sets
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredentialSets: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/credentialsets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of device types (drivers).
         * @summary Get the device types
         * @param {boolean} [refresh] Whether to reload all drivers from sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceTypes: async (refresh?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devicetypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of device domains.
         * @summary Get the device domains
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current list of hooks.
         * @summary Get the hooks
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHooks: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves some general info about Netshot server.
         * @summary Get Netshot server info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/serverinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of Netshot users.
         * @summary Get the users
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a credential set, by ID.
         * @summary Update a credential set
         * @param {number} id Credential set ID
         * @param {DeviceCredentialSetRestApiView} [deviceCredentialSetRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCredentialSet: async (id: number, deviceCredentialSetRestApiView?: DeviceCredentialSetRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setCredentialSet', 'id', id)
            const localVarPath = `/credentialsets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceCredentialSetRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a device domain, by ID.
         * @summary Update a device domain
         * @param {number} id Domain ID
         * @param {RsDomainRestApiView} [rsDomainRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDomain: async (id: number, rsDomainRestApiView?: RsDomainRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setDomain', 'id', id)
            const localVarPath = `/domains/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsDomainRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a hook, by ID.
         * @summary Update a hook
         * @param {number} id Hook ID
         * @param {HookRestApiView} [hookRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHook: async (id: number, hookRestApiView?: HookRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setHook', 'id', id)
            const localVarPath = `/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hookRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a Netshot user, by ID.
         * @summary Update a Netshot user
         * @param {number} id User ID
         * @param {RsUserRestApiView} [rsUserRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUser: async (id: number, rsUserRestApiView?: RsUserRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsUserRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new API token.
         * @summary Add a new API token
         * @param {RsApiTokenRestApiView} [rsApiTokenRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addApiToken(rsApiTokenRestApiView?: RsApiTokenRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiTokenRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addApiToken(rsApiTokenRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a credential set, which then can be used to authenticate against the devices.
         * @summary Add a credential set
         * @param {DeviceCredentialSetRestApiView} [deviceCredentialSetRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCredentialSet(deviceCredentialSetRestApiView?: DeviceCredentialSetRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCredentialSet(deviceCredentialSetRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a device domain.
         * @summary Add a device domain
         * @param {RsDomainRestApiView} [rsDomainRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDomain(rsDomainRestApiView?: RsDomainRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RsDomainRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDomain(rsDomainRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a hook. Based on given criteria, Netshot will run the given action when specific events occur.
         * @summary Add a hook
         * @param {HookRestApiView} [hookRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addHook(hookRestApiView?: HookRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addHook(hookRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Netshot user.
         * @summary Add a user to Netshot
         * @param {RsUserRestApiView} [rsUserRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUser(rsUserRestApiView?: RsUserRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UiUserRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUser(rsUserRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes an API token, by ID.
         * @summary Remove an API token
         * @param {number} id Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiToken(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the given credential set, by ID.
         * @summary Remove a credential set
         * @param {number} id Credential set ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCredentialSet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCredentialSet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove the given device domain, by ID.
         * @summary Remove a device domain
         * @param {number} id Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomain(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomain(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes the hook, by ID.
         * @summary Remove a hook
         * @param {number} id Hook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHook(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a user from the Netshot database.
         * @summary Remove a Netshot user.
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of API tokens.
         * @summary Get the API tokens
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiTokens(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiTokenRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiTokens(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns cluster mastership info of the current node. Might be used by local-balancer to redirect http to the proper server (return code 205 means the local server is not master).
         * @summary Check if local server is cluster master
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterMasterStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RsClusterMasterCheckRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterMasterStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the members of the Netshot high availability cluster (empty list if clustering is not enabled).
         * @summary Get cluster members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClusterMembers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClusterMemberRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClusterMembers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of global credential sets (SSH, SNMP, etc. accounts) for authentication against the devices.
         * @summary Get the global credential sets
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCredentialSets(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceCredentialSetRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCredentialSets(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of device types (drivers).
         * @summary Get the device types
         * @param {boolean} [refresh] Whether to reload all drivers from sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceTypes(refresh?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceDriverRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceTypes(refresh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of device domains.
         * @summary Get the device domains
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomains(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsDomainRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomains(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the current list of hooks.
         * @summary Get the hooks
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHooks(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HookRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHooks(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves some general info about Netshot server.
         * @summary Get Netshot server info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RsServerInfoRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of Netshot users.
         * @summary Get the users
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UiUserRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a credential set, by ID.
         * @summary Update a credential set
         * @param {number} id Credential set ID
         * @param {DeviceCredentialSetRestApiView} [deviceCredentialSetRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCredentialSet(id: number, deviceCredentialSetRestApiView?: DeviceCredentialSetRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceCredentialSetRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCredentialSet(id, deviceCredentialSetRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a device domain, by ID.
         * @summary Update a device domain
         * @param {number} id Domain ID
         * @param {RsDomainRestApiView} [rsDomainRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDomain(id: number, rsDomainRestApiView?: RsDomainRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RsDomainRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDomain(id, rsDomainRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a hook, by ID.
         * @summary Update a hook
         * @param {number} id Hook ID
         * @param {HookRestApiView} [hookRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setHook(id: number, hookRestApiView?: HookRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setHook(id, hookRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a Netshot user, by ID.
         * @summary Update a Netshot user
         * @param {number} id User ID
         * @param {RsUserRestApiView} [rsUserRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUser(id: number, rsUserRestApiView?: RsUserRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UiUserRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUser(id, rsUserRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Creates a new API token.
         * @summary Add a new API token
         * @param {RsApiTokenRestApiView} [rsApiTokenRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addApiToken(rsApiTokenRestApiView?: RsApiTokenRestApiView, options?: any): AxiosPromise<ApiTokenRestApiView> {
            return localVarFp.addApiToken(rsApiTokenRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a credential set, which then can be used to authenticate against the devices.
         * @summary Add a credential set
         * @param {DeviceCredentialSetRestApiView} [deviceCredentialSetRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredentialSet(deviceCredentialSetRestApiView?: DeviceCredentialSetRestApiView, options?: any): AxiosPromise<void> {
            return localVarFp.addCredentialSet(deviceCredentialSetRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a device domain.
         * @summary Add a device domain
         * @param {RsDomainRestApiView} [rsDomainRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDomain(rsDomainRestApiView?: RsDomainRestApiView, options?: any): AxiosPromise<RsDomainRestApiView> {
            return localVarFp.addDomain(rsDomainRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a hook. Based on given criteria, Netshot will run the given action when specific events occur.
         * @summary Add a hook
         * @param {HookRestApiView} [hookRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHook(hookRestApiView?: HookRestApiView, options?: any): AxiosPromise<HookRestApiView> {
            return localVarFp.addHook(hookRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Netshot user.
         * @summary Add a user to Netshot
         * @param {RsUserRestApiView} [rsUserRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(rsUserRestApiView?: RsUserRestApiView, options?: any): AxiosPromise<UiUserRestApiView> {
            return localVarFp.addUser(rsUserRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes an API token, by ID.
         * @summary Remove an API token
         * @param {number} id Token ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiToken(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApiToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the given credential set, by ID.
         * @summary Remove a credential set
         * @param {number} id Credential set ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredentialSet(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCredentialSet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the given device domain, by ID.
         * @summary Remove a device domain
         * @param {number} id Domain ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDomain(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the hook, by ID.
         * @summary Remove a hook
         * @param {number} id Hook ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHook(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a user from the Netshot database.
         * @summary Remove a Netshot user.
         * @param {number} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of API tokens.
         * @summary Get the API tokens
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiTokens(offset?: number, limit?: number, options?: any): AxiosPromise<Array<ApiTokenRestApiView>> {
            return localVarFp.getApiTokens(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns cluster mastership info of the current node. Might be used by local-balancer to redirect http to the proper server (return code 205 means the local server is not master).
         * @summary Check if local server is cluster master
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterMasterStatus(options?: any): AxiosPromise<RsClusterMasterCheckRestApiView> {
            return localVarFp.getClusterMasterStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the members of the Netshot high availability cluster (empty list if clustering is not enabled).
         * @summary Get cluster members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterMembers(options?: any): AxiosPromise<Array<ClusterMemberRestApiView>> {
            return localVarFp.getClusterMembers(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of global credential sets (SSH, SNMP, etc. accounts) for authentication against the devices.
         * @summary Get the global credential sets
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredentialSets(offset?: number, limit?: number, options?: any): AxiosPromise<Array<DeviceCredentialSetRestApiView>> {
            return localVarFp.getCredentialSets(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of device types (drivers).
         * @summary Get the device types
         * @param {boolean} [refresh] Whether to reload all drivers from sources
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceTypes(refresh?: boolean, options?: any): AxiosPromise<Array<DeviceDriverRestApiView>> {
            return localVarFp.getDeviceTypes(refresh, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of device domains.
         * @summary Get the device domains
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains(offset?: number, limit?: number, options?: any): AxiosPromise<Array<RsDomainRestApiView>> {
            return localVarFp.getDomains(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current list of hooks.
         * @summary Get the hooks
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHooks(offset?: number, limit?: number, options?: any): AxiosPromise<Array<HookRestApiView>> {
            return localVarFp.getHooks(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves some general info about Netshot server.
         * @summary Get Netshot server info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(options?: any): AxiosPromise<RsServerInfoRestApiView> {
            return localVarFp.getServerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of Netshot users.
         * @summary Get the users
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(offset?: number, limit?: number, options?: any): AxiosPromise<Array<UiUserRestApiView>> {
            return localVarFp.getUsers(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a credential set, by ID.
         * @summary Update a credential set
         * @param {number} id Credential set ID
         * @param {DeviceCredentialSetRestApiView} [deviceCredentialSetRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCredentialSet(id: number, deviceCredentialSetRestApiView?: DeviceCredentialSetRestApiView, options?: any): AxiosPromise<DeviceCredentialSetRestApiView> {
            return localVarFp.setCredentialSet(id, deviceCredentialSetRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a device domain, by ID.
         * @summary Update a device domain
         * @param {number} id Domain ID
         * @param {RsDomainRestApiView} [rsDomainRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDomain(id: number, rsDomainRestApiView?: RsDomainRestApiView, options?: any): AxiosPromise<RsDomainRestApiView> {
            return localVarFp.setDomain(id, rsDomainRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a hook, by ID.
         * @summary Update a hook
         * @param {number} id Hook ID
         * @param {HookRestApiView} [hookRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHook(id: number, hookRestApiView?: HookRestApiView, options?: any): AxiosPromise<HookRestApiView> {
            return localVarFp.setHook(id, hookRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a Netshot user, by ID.
         * @summary Update a Netshot user
         * @param {number} id User ID
         * @param {RsUserRestApiView} [rsUserRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUser(id: number, rsUserRestApiView?: RsUserRestApiView, options?: any): AxiosPromise<UiUserRestApiView> {
            return localVarFp.setUser(id, rsUserRestApiView, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Creates a new API token.
     * @summary Add a new API token
     * @param {RsApiTokenRestApiView} [rsApiTokenRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public addApiToken(rsApiTokenRestApiView?: RsApiTokenRestApiView, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).addApiToken(rsApiTokenRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a credential set, which then can be used to authenticate against the devices.
     * @summary Add a credential set
     * @param {DeviceCredentialSetRestApiView} [deviceCredentialSetRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public addCredentialSet(deviceCredentialSetRestApiView?: DeviceCredentialSetRestApiView, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).addCredentialSet(deviceCredentialSetRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a device domain.
     * @summary Add a device domain
     * @param {RsDomainRestApiView} [rsDomainRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public addDomain(rsDomainRestApiView?: RsDomainRestApiView, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).addDomain(rsDomainRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a hook. Based on given criteria, Netshot will run the given action when specific events occur.
     * @summary Add a hook
     * @param {HookRestApiView} [hookRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public addHook(hookRestApiView?: HookRestApiView, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).addHook(hookRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Netshot user.
     * @summary Add a user to Netshot
     * @param {RsUserRestApiView} [rsUserRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public addUser(rsUserRestApiView?: RsUserRestApiView, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).addUser(rsUserRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes an API token, by ID.
     * @summary Remove an API token
     * @param {number} id Token ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteApiToken(id: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteApiToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the given credential set, by ID.
     * @summary Remove a credential set
     * @param {number} id Credential set ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteCredentialSet(id: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteCredentialSet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the given device domain, by ID.
     * @summary Remove a device domain
     * @param {number} id Domain ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteDomain(id: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteDomain(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the hook, by ID.
     * @summary Remove a hook
     * @param {number} id Hook ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteHook(id: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteHook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a user from the Netshot database.
     * @summary Remove a Netshot user.
     * @param {number} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteUser(id: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of API tokens.
     * @summary Get the API tokens
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getApiTokens(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getApiTokens(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns cluster mastership info of the current node. Might be used by local-balancer to redirect http to the proper server (return code 205 means the local server is not master).
     * @summary Check if local server is cluster master
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getClusterMasterStatus(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getClusterMasterStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the members of the Netshot high availability cluster (empty list if clustering is not enabled).
     * @summary Get cluster members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getClusterMembers(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getClusterMembers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of global credential sets (SSH, SNMP, etc. accounts) for authentication against the devices.
     * @summary Get the global credential sets
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getCredentialSets(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getCredentialSets(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of device types (drivers).
     * @summary Get the device types
     * @param {boolean} [refresh] Whether to reload all drivers from sources
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getDeviceTypes(refresh?: boolean, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getDeviceTypes(refresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of device domains.
     * @summary Get the device domains
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getDomains(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getDomains(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current list of hooks.
     * @summary Get the hooks
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getHooks(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getHooks(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves some general info about Netshot server.
     * @summary Get Netshot server info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getServerInfo(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getServerInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of Netshot users.
     * @summary Get the users
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUsers(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUsers(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a credential set, by ID.
     * @summary Update a credential set
     * @param {number} id Credential set ID
     * @param {DeviceCredentialSetRestApiView} [deviceCredentialSetRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public setCredentialSet(id: number, deviceCredentialSetRestApiView?: DeviceCredentialSetRestApiView, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setCredentialSet(id, deviceCredentialSetRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a device domain, by ID.
     * @summary Update a device domain
     * @param {number} id Domain ID
     * @param {RsDomainRestApiView} [rsDomainRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public setDomain(id: number, rsDomainRestApiView?: RsDomainRestApiView, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setDomain(id, rsDomainRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a hook, by ID.
     * @summary Update a hook
     * @param {number} id Hook ID
     * @param {HookRestApiView} [hookRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public setHook(id: number, hookRestApiView?: HookRestApiView, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setHook(id, hookRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a Netshot user, by ID.
     * @summary Update a Netshot user
     * @param {number} id User ID
     * @param {RsUserRestApiView} [rsUserRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public setUser(id: number, rsUserRestApiView?: RsUserRestApiView, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).setUser(id, rsUserRestApiView, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ComplianceApi - axios parameter creator
 * @export
 */
export const ComplianceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an hardware compliance rule.
         * @summary Add an hardware compliance rule
         * @param {RsHardwareRuleRestApiView} [rsHardwareRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHardwareRule: async (rsHardwareRuleRestApiView?: RsHardwareRuleRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hardwarerules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsHardwareRuleRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a compliance policy.
         * @summary Add a compliance policy
         * @param {RsPolicyRestApiView} [rsPolicyRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPolicy: async (rsPolicyRestApiView?: RsPolicyRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsPolicyRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a compliance rule. The associated policy must already exist.
         * @summary Add a compliance rule
         * @param {RsRuleRestApiView} [rsRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRule: async (rsRuleRestApiView?: RsRuleRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsRuleRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a software compliance rule.
         * @summary Add a software compliance rule
         * @param {RsSoftwareRuleRestApiView} [rsSoftwareRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSoftwareRule: async (rsSoftwareRuleRestApiView?: RsSoftwareRuleRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/softwarerules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsSoftwareRuleRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an hardware compliance rule, by ID.
         * @summary Remove an hardware compliance rule
         * @param {number} id Hardware rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHardwareRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteHardwareRule', 'id', id)
            const localVarPath = `/hardwarerules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a given compliance policy, by ID
         * @summary Remove a compliance policy
         * @param {number} id Policy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePolicy', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a compliance rule, by ID.
         * @summary Remove a compliance rule
         * @param {number} id Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRule', 'id', id)
            const localVarPath = `/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a software compliance rule, by ID
         * @summary Remove a software compliance rule
         * @param {number} id Software rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSoftwareRule: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSoftwareRule', 'id', id)
            const localVarPath = `/softwarerules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the configuration compliance status of devices; optionally filtered by domain, group, policy or compliance level.
         * @summary Get the configuration compliance status of devices
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>} [result] Filter on given result(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigComplianceDeviceStatuses: async (domain?: Set<number>, group?: Set<number>, policy?: Set<number>, result?: Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/configcompliancedevicestatuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }

            if (group) {
                localVarQueryParameter['group'] = Array.from(group);
            }

            if (policy) {
                localVarQueryParameter['policy'] = Array.from(policy);
            }

            if (result) {
                localVarQueryParameter['result'] = Array.from(result);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the compliance results for a give device, by ID.
         * @summary Get the compliance results for a device
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceComplianceResults: async (id: number, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeviceComplianceResults', 'id', id)
            const localVarPath = `/devices/{id}/complianceresults`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of devices which have an exemption against a given compliance rule, by ID.
         * @summary Get the exempted devices of a compliance rule
         * @param {number} id Rule ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExemptedDevices: async (id: number, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getExemptedDevices', 'id', id)
            const localVarPath = `/rule/{id}/exempteddevices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the compliance status of a given device group, by ID.
         * @summary Get the compliance status of a device group
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupConfigComplianceStats: async (domain?: Set<number>, group?: Set<number>, policy?: Set<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/groupconfigcompliancestats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }

            if (group) {
                localVarQueryParameter['group'] = Array.from(group);
            }

            if (policy) {
                localVarQueryParameter['policy'] = Array.from(policy);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of non-compliance devices part of a given group, optionally filtered by domains and policies
         * @summary Get the non compliant devices of a group
         * @param {number} id Group ID
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupConfigNonCompliantDevices: async (id: number, domain?: Set<number>, policy?: Set<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupConfigNonCompliantDevices', 'id', id)
            const localVarPath = `/reports/groupconfignoncompliantdevices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }

            if (policy) {
                localVarQueryParameter['policy'] = Array.from(policy);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of devices of a given group by ID, and matching the given software compliance level.
         * @summary Get the devices of a group based on software compliance level
         * @param {number} id Group ID
         * @param {string} level Software compliance level
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupDevicesBySoftwareLevel: async (id: number, level: string, domain?: Set<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupDevicesBySoftwareLevel', 'id', id)
            // verify required parameter 'level' is not null or undefined
            assertParamExists('getGroupDevicesBySoftwareLevel', 'level', level)
            const localVarPath = `/reports/groupdevicesbysoftwarelevel/{id}/{level}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"level"}}`, encodeURIComponent(String(level)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the software compliance status of devices, optionally filtered by a list of device domains.
         * @summary Get the global software compliance status
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupSoftwareComplianceStats: async (domain?: Set<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/groupsoftwarecompliancestats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of hardware compliance rules.
         * @summary Get the hardware compliance rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardwareRules: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hardwarerules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of devices getting End-of-Life (type \'eol\') or End-of-Sale (type \'eos\') at the given date (or never if \'date\' is not given).
         * @summary Get the End-of-Life or End-of-Sale devices matching a date.
         * @param {string} type eos (end-of-sale) or eol (end-of-life), type of date
         * @param {number} date EoX date to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardwareStatusDevices: async (type: string, date: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getHardwareStatusDevices', 'type', type)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getHardwareStatusDevices', 'date', date)
            const localVarPath = `/reports/hardwaresupportdevices/{type}/{date}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the global hardware support status, i.e. a list of End-of-Life and End-of-Sale dates with the corresponding device count.
         * @summary Get the global hardware support status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardwareSupportStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/hardwaresupportstats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of compliance policies.
         * @summary Get the compliance policies
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the rules owned by a given compliance policy.
         * @summary Get the compliance rules of a policy
         * @param {number} id Policy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyRules: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicyRules', 'id', id)
            const localVarPath = `/rules/policy/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of software compliance rules.
         * @summary Get the software compliance rules
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSoftwareRules: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/softwarerules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits an hardware compliance rule, by ID.
         * @summary Update an hardware compliance rule
         * @param {number} id Hardware rule ID
         * @param {RsHardwareRuleRestApiView} [rsHardwareRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHardwareRule: async (id: number, rsHardwareRuleRestApiView?: RsHardwareRuleRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setHardwareRule', 'id', id)
            const localVarPath = `/hardwarerules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsHardwareRuleRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a compliance policy, by ID.
         * @summary Update a compliance policy
         * @param {number} id Policy ID
         * @param {RsPolicyRestApiView} [rsPolicyRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPolicy: async (id: number, rsPolicyRestApiView?: RsPolicyRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setPolicy', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsPolicyRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a compliance rule, by ID.
         * @summary Update a compliance rule
         * @param {number} id Rule ID
         * @param {RsRuleRestApiView} [rsRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRule: async (id: number, rsRuleRestApiView?: RsRuleRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setRule', 'id', id)
            const localVarPath = `/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsRuleRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a software compliance rule.
         * @summary Update a software compliance rule
         * @param {number} id Software rule ID
         * @param {RsSoftwareRuleRestApiView} [rsSoftwareRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSoftwareRule: async (id: number, rsSoftwareRuleRestApiView?: RsSoftwareRuleRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setSoftwareRule', 'id', id)
            const localVarPath = `/softwarerules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsSoftwareRuleRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test a compliance rule against a given device, in dry run mode.
         * @summary Test a compliance rule
         * @param {RsRuleTestRestApiView} [rsRuleTestRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRule: async (rsRuleTestRestApiView?: RsRuleTestRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rules/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsRuleTestRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ComplianceApi - functional programming interface
 * @export
 */
export const ComplianceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ComplianceApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an hardware compliance rule.
         * @summary Add an hardware compliance rule
         * @param {RsHardwareRuleRestApiView} [rsHardwareRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addHardwareRule(rsHardwareRuleRestApiView?: RsHardwareRuleRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HardwareRuleRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addHardwareRule(rsHardwareRuleRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a compliance policy.
         * @summary Add a compliance policy
         * @param {RsPolicyRestApiView} [rsPolicyRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPolicy(rsPolicyRestApiView?: RsPolicyRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPolicy(rsPolicyRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a compliance rule. The associated policy must already exist.
         * @summary Add a compliance rule
         * @param {RsRuleRestApiView} [rsRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRule(rsRuleRestApiView?: RsRuleRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRule(rsRuleRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a software compliance rule.
         * @summary Add a software compliance rule
         * @param {RsSoftwareRuleRestApiView} [rsSoftwareRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSoftwareRule(rsSoftwareRuleRestApiView?: RsSoftwareRuleRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoftwareRuleRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSoftwareRule(rsSoftwareRuleRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes an hardware compliance rule, by ID.
         * @summary Remove an hardware compliance rule
         * @param {number} id Hardware rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHardwareRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHardwareRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a given compliance policy, by ID
         * @summary Remove a compliance policy
         * @param {number} id Policy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a compliance rule, by ID.
         * @summary Remove a compliance rule
         * @param {number} id Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a software compliance rule, by ID
         * @summary Remove a software compliance rule
         * @param {number} id Software rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSoftwareRule(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSoftwareRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the configuration compliance status of devices; optionally filtered by domain, group, policy or compliance level.
         * @summary Get the configuration compliance status of devices
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>} [result] Filter on given result(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigComplianceDeviceStatuses(domain?: Set<number>, group?: Set<number>, policy?: Set<number>, result?: Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsLightPolicyRuleDeviceRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigComplianceDeviceStatuses(domain, group, policy, result, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the compliance results for a give device, by ID.
         * @summary Get the compliance results for a device
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceComplianceResults(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsDeviceRuleRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceComplianceResults(id, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of devices which have an exemption against a given compliance rule, by ID.
         * @summary Get the exempted devices of a compliance rule
         * @param {number} id Rule ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExemptedDevices(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsLightExemptedDeviceRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExemptedDevices(id, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the compliance status of a given device group, by ID.
         * @summary Get the compliance status of a device group
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupConfigComplianceStats(domain?: Set<number>, group?: Set<number>, policy?: Set<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsGroupConfigComplianceStatRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupConfigComplianceStats(domain, group, policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of non-compliance devices part of a given group, optionally filtered by domains and policies
         * @summary Get the non compliant devices of a group
         * @param {number} id Group ID
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupConfigNonCompliantDevices(id: number, domain?: Set<number>, policy?: Set<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsLightPolicyRuleDeviceRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupConfigNonCompliantDevices(id, domain, policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of devices of a given group by ID, and matching the given software compliance level.
         * @summary Get the devices of a group based on software compliance level
         * @param {number} id Group ID
         * @param {string} level Software compliance level
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupDevicesBySoftwareLevel(id: number, level: string, domain?: Set<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsLightSoftwareLevelDeviceRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupDevicesBySoftwareLevel(id, level, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the software compliance status of devices, optionally filtered by a list of device domains.
         * @summary Get the global software compliance status
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupSoftwareComplianceStats(domain?: Set<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsGroupSoftwareComplianceStatRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupSoftwareComplianceStats(domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of hardware compliance rules.
         * @summary Get the hardware compliance rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHardwareRules(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HardwareRuleRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHardwareRules(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of devices getting End-of-Life (type \'eol\') or End-of-Sale (type \'eos\') at the given date (or never if \'date\' is not given).
         * @summary Get the End-of-Life or End-of-Sale devices matching a date.
         * @param {string} type eos (end-of-sale) or eol (end-of-life), type of date
         * @param {number} date EoX date to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHardwareStatusDevices(type: string, date: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsLightDeviceRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHardwareStatusDevices(type, date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the global hardware support status, i.e. a list of End-of-Life and End-of-Sale dates with the corresponding device count.
         * @summary Get the global hardware support status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHardwareSupportStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsHardwareSupportStatRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHardwareSupportStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of compliance policies.
         * @summary Get the compliance policies
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicies(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PolicyRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicies(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the rules owned by a given compliance policy.
         * @summary Get the compliance rules of a policy
         * @param {number} id Policy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicyRules(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicyRules(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of software compliance rules.
         * @summary Get the software compliance rules
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSoftwareRules(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SoftwareRuleRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSoftwareRules(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits an hardware compliance rule, by ID.
         * @summary Update an hardware compliance rule
         * @param {number} id Hardware rule ID
         * @param {RsHardwareRuleRestApiView} [rsHardwareRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setHardwareRule(id: number, rsHardwareRuleRestApiView?: RsHardwareRuleRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HardwareRuleRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setHardwareRule(id, rsHardwareRuleRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a compliance policy, by ID.
         * @summary Update a compliance policy
         * @param {number} id Policy ID
         * @param {RsPolicyRestApiView} [rsPolicyRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPolicy(id: number, rsPolicyRestApiView?: RsPolicyRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPolicy(id, rsPolicyRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a compliance rule, by ID.
         * @summary Update a compliance rule
         * @param {number} id Rule ID
         * @param {RsRuleRestApiView} [rsRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRule(id: number, rsRuleRestApiView?: RsRuleRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRule(id, rsRuleRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a software compliance rule.
         * @summary Update a software compliance rule
         * @param {number} id Software rule ID
         * @param {RsSoftwareRuleRestApiView} [rsSoftwareRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSoftwareRule(id: number, rsSoftwareRuleRestApiView?: RsSoftwareRuleRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoftwareRuleRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSoftwareRule(id, rsSoftwareRuleRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test a compliance rule against a given device, in dry run mode.
         * @summary Test a compliance rule
         * @param {RsRuleTestRestApiView} [rsRuleTestRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testRule(rsRuleTestRestApiView?: RsRuleTestRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RsRuleTestResultRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testRule(rsRuleTestRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ComplianceApi - factory interface
 * @export
 */
export const ComplianceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ComplianceApiFp(configuration)
    return {
        /**
         * Creates an hardware compliance rule.
         * @summary Add an hardware compliance rule
         * @param {RsHardwareRuleRestApiView} [rsHardwareRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHardwareRule(rsHardwareRuleRestApiView?: RsHardwareRuleRestApiView, options?: any): AxiosPromise<HardwareRuleRestApiView> {
            return localVarFp.addHardwareRule(rsHardwareRuleRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a compliance policy.
         * @summary Add a compliance policy
         * @param {RsPolicyRestApiView} [rsPolicyRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPolicy(rsPolicyRestApiView?: RsPolicyRestApiView, options?: any): AxiosPromise<PolicyRestApiView> {
            return localVarFp.addPolicy(rsPolicyRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a compliance rule. The associated policy must already exist.
         * @summary Add a compliance rule
         * @param {RsRuleRestApiView} [rsRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRule(rsRuleRestApiView?: RsRuleRestApiView, options?: any): AxiosPromise<RuleRestApiView> {
            return localVarFp.addRule(rsRuleRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a software compliance rule.
         * @summary Add a software compliance rule
         * @param {RsSoftwareRuleRestApiView} [rsSoftwareRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSoftwareRule(rsSoftwareRuleRestApiView?: RsSoftwareRuleRestApiView, options?: any): AxiosPromise<SoftwareRuleRestApiView> {
            return localVarFp.addSoftwareRule(rsSoftwareRuleRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes an hardware compliance rule, by ID.
         * @summary Remove an hardware compliance rule
         * @param {number} id Hardware rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHardwareRule(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHardwareRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a given compliance policy, by ID
         * @summary Remove a compliance policy
         * @param {number} id Policy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deletePolicy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a compliance rule, by ID.
         * @summary Remove a compliance rule
         * @param {number} id Rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a software compliance rule, by ID
         * @summary Remove a software compliance rule
         * @param {number} id Software rule ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSoftwareRule(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSoftwareRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the configuration compliance status of devices; optionally filtered by domain, group, policy or compliance level.
         * @summary Get the configuration compliance status of devices
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>} [result] Filter on given result(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigComplianceDeviceStatuses(domain?: Set<number>, group?: Set<number>, policy?: Set<number>, result?: Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>, options?: any): AxiosPromise<Array<RsLightPolicyRuleDeviceRestApiView>> {
            return localVarFp.getConfigComplianceDeviceStatuses(domain, group, policy, result, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the compliance results for a give device, by ID.
         * @summary Get the compliance results for a device
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceComplianceResults(id: number, offset?: number, limit?: number, options?: any): AxiosPromise<Array<RsDeviceRuleRestApiView>> {
            return localVarFp.getDeviceComplianceResults(id, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of devices which have an exemption against a given compliance rule, by ID.
         * @summary Get the exempted devices of a compliance rule
         * @param {number} id Rule ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExemptedDevices(id: number, offset?: number, limit?: number, options?: any): AxiosPromise<Array<RsLightExemptedDeviceRestApiView>> {
            return localVarFp.getExemptedDevices(id, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the compliance status of a given device group, by ID.
         * @summary Get the compliance status of a device group
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupConfigComplianceStats(domain?: Set<number>, group?: Set<number>, policy?: Set<number>, options?: any): AxiosPromise<Array<RsGroupConfigComplianceStatRestApiView>> {
            return localVarFp.getGroupConfigComplianceStats(domain, group, policy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of non-compliance devices part of a given group, optionally filtered by domains and policies
         * @summary Get the non compliant devices of a group
         * @param {number} id Group ID
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupConfigNonCompliantDevices(id: number, domain?: Set<number>, policy?: Set<number>, options?: any): AxiosPromise<Array<RsLightPolicyRuleDeviceRestApiView>> {
            return localVarFp.getGroupConfigNonCompliantDevices(id, domain, policy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of devices of a given group by ID, and matching the given software compliance level.
         * @summary Get the devices of a group based on software compliance level
         * @param {number} id Group ID
         * @param {string} level Software compliance level
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupDevicesBySoftwareLevel(id: number, level: string, domain?: Set<number>, options?: any): AxiosPromise<Array<RsLightSoftwareLevelDeviceRestApiView>> {
            return localVarFp.getGroupDevicesBySoftwareLevel(id, level, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the software compliance status of devices, optionally filtered by a list of device domains.
         * @summary Get the global software compliance status
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupSoftwareComplianceStats(domain?: Set<number>, options?: any): AxiosPromise<Array<RsGroupSoftwareComplianceStatRestApiView>> {
            return localVarFp.getGroupSoftwareComplianceStats(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of hardware compliance rules.
         * @summary Get the hardware compliance rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardwareRules(options?: any): AxiosPromise<Array<HardwareRuleRestApiView>> {
            return localVarFp.getHardwareRules(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of devices getting End-of-Life (type \'eol\') or End-of-Sale (type \'eos\') at the given date (or never if \'date\' is not given).
         * @summary Get the End-of-Life or End-of-Sale devices matching a date.
         * @param {string} type eos (end-of-sale) or eol (end-of-life), type of date
         * @param {number} date EoX date to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardwareStatusDevices(type: string, date: number, options?: any): AxiosPromise<Array<RsLightDeviceRestApiView>> {
            return localVarFp.getHardwareStatusDevices(type, date, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the global hardware support status, i.e. a list of End-of-Life and End-of-Sale dates with the corresponding device count.
         * @summary Get the global hardware support status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardwareSupportStats(options?: any): AxiosPromise<Array<RsHardwareSupportStatRestApiView>> {
            return localVarFp.getHardwareSupportStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of compliance policies.
         * @summary Get the compliance policies
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicies(offset?: number, limit?: number, options?: any): AxiosPromise<Array<PolicyRestApiView>> {
            return localVarFp.getPolicies(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the rules owned by a given compliance policy.
         * @summary Get the compliance rules of a policy
         * @param {number} id Policy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicyRules(id: number, options?: any): AxiosPromise<Array<RuleRestApiView>> {
            return localVarFp.getPolicyRules(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of software compliance rules.
         * @summary Get the software compliance rules
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSoftwareRules(offset?: number, limit?: number, options?: any): AxiosPromise<Array<SoftwareRuleRestApiView>> {
            return localVarFp.getSoftwareRules(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits an hardware compliance rule, by ID.
         * @summary Update an hardware compliance rule
         * @param {number} id Hardware rule ID
         * @param {RsHardwareRuleRestApiView} [rsHardwareRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHardwareRule(id: number, rsHardwareRuleRestApiView?: RsHardwareRuleRestApiView, options?: any): AxiosPromise<HardwareRuleRestApiView> {
            return localVarFp.setHardwareRule(id, rsHardwareRuleRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a compliance policy, by ID.
         * @summary Update a compliance policy
         * @param {number} id Policy ID
         * @param {RsPolicyRestApiView} [rsPolicyRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPolicy(id: number, rsPolicyRestApiView?: RsPolicyRestApiView, options?: any): AxiosPromise<PolicyRestApiView> {
            return localVarFp.setPolicy(id, rsPolicyRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a compliance rule, by ID.
         * @summary Update a compliance rule
         * @param {number} id Rule ID
         * @param {RsRuleRestApiView} [rsRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRule(id: number, rsRuleRestApiView?: RsRuleRestApiView, options?: any): AxiosPromise<RuleRestApiView> {
            return localVarFp.setRule(id, rsRuleRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a software compliance rule.
         * @summary Update a software compliance rule
         * @param {number} id Software rule ID
         * @param {RsSoftwareRuleRestApiView} [rsSoftwareRuleRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSoftwareRule(id: number, rsSoftwareRuleRestApiView?: RsSoftwareRuleRestApiView, options?: any): AxiosPromise<SoftwareRuleRestApiView> {
            return localVarFp.setSoftwareRule(id, rsSoftwareRuleRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Test a compliance rule against a given device, in dry run mode.
         * @summary Test a compliance rule
         * @param {RsRuleTestRestApiView} [rsRuleTestRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testRule(rsRuleTestRestApiView?: RsRuleTestRestApiView, options?: any): AxiosPromise<RsRuleTestResultRestApiView> {
            return localVarFp.testRule(rsRuleTestRestApiView, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComplianceApi - object-oriented interface
 * @export
 * @class ComplianceApi
 * @extends {BaseAPI}
 */
export class ComplianceApi extends BaseAPI {
    /**
     * Creates an hardware compliance rule.
     * @summary Add an hardware compliance rule
     * @param {RsHardwareRuleRestApiView} [rsHardwareRuleRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public addHardwareRule(rsHardwareRuleRestApiView?: RsHardwareRuleRestApiView, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).addHardwareRule(rsHardwareRuleRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a compliance policy.
     * @summary Add a compliance policy
     * @param {RsPolicyRestApiView} [rsPolicyRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public addPolicy(rsPolicyRestApiView?: RsPolicyRestApiView, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).addPolicy(rsPolicyRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a compliance rule. The associated policy must already exist.
     * @summary Add a compliance rule
     * @param {RsRuleRestApiView} [rsRuleRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public addRule(rsRuleRestApiView?: RsRuleRestApiView, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).addRule(rsRuleRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a software compliance rule.
     * @summary Add a software compliance rule
     * @param {RsSoftwareRuleRestApiView} [rsSoftwareRuleRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public addSoftwareRule(rsSoftwareRuleRestApiView?: RsSoftwareRuleRestApiView, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).addSoftwareRule(rsSoftwareRuleRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes an hardware compliance rule, by ID.
     * @summary Remove an hardware compliance rule
     * @param {number} id Hardware rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public deleteHardwareRule(id: number, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).deleteHardwareRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a given compliance policy, by ID
     * @summary Remove a compliance policy
     * @param {number} id Policy ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public deletePolicy(id: number, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).deletePolicy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a compliance rule, by ID.
     * @summary Remove a compliance rule
     * @param {number} id Rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public deleteRule(id: number, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).deleteRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a software compliance rule, by ID
     * @summary Remove a software compliance rule
     * @param {number} id Software rule ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public deleteSoftwareRule(id: number, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).deleteSoftwareRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the configuration compliance status of devices; optionally filtered by domain, group, policy or compliance level.
     * @summary Get the configuration compliance status of devices
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {Set<number>} [group] Filter on given group ID(s)
     * @param {Set<number>} [policy] Filter on given policy ID(s)
     * @param {Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>} [result] Filter on given result(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getConfigComplianceDeviceStatuses(domain?: Set<number>, group?: Set<number>, policy?: Set<number>, result?: Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getConfigComplianceDeviceStatuses(domain, group, policy, result, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the compliance results for a give device, by ID.
     * @summary Get the compliance results for a device
     * @param {number} id Device ID
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getDeviceComplianceResults(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getDeviceComplianceResults(id, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of devices which have an exemption against a given compliance rule, by ID.
     * @summary Get the exempted devices of a compliance rule
     * @param {number} id Rule ID
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getExemptedDevices(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getExemptedDevices(id, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the compliance status of a given device group, by ID.
     * @summary Get the compliance status of a device group
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {Set<number>} [group] Filter on given group ID(s)
     * @param {Set<number>} [policy] Filter on given policy ID(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getGroupConfigComplianceStats(domain?: Set<number>, group?: Set<number>, policy?: Set<number>, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getGroupConfigComplianceStats(domain, group, policy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of non-compliance devices part of a given group, optionally filtered by domains and policies
     * @summary Get the non compliant devices of a group
     * @param {number} id Group ID
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {Set<number>} [policy] Filter on given policy ID(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getGroupConfigNonCompliantDevices(id: number, domain?: Set<number>, policy?: Set<number>, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getGroupConfigNonCompliantDevices(id, domain, policy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of devices of a given group by ID, and matching the given software compliance level.
     * @summary Get the devices of a group based on software compliance level
     * @param {number} id Group ID
     * @param {string} level Software compliance level
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getGroupDevicesBySoftwareLevel(id: number, level: string, domain?: Set<number>, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getGroupDevicesBySoftwareLevel(id, level, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the software compliance status of devices, optionally filtered by a list of device domains.
     * @summary Get the global software compliance status
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getGroupSoftwareComplianceStats(domain?: Set<number>, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getGroupSoftwareComplianceStats(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of hardware compliance rules.
     * @summary Get the hardware compliance rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getHardwareRules(options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getHardwareRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of devices getting End-of-Life (type \'eol\') or End-of-Sale (type \'eos\') at the given date (or never if \'date\' is not given).
     * @summary Get the End-of-Life or End-of-Sale devices matching a date.
     * @param {string} type eos (end-of-sale) or eol (end-of-life), type of date
     * @param {number} date EoX date to filter on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getHardwareStatusDevices(type: string, date: number, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getHardwareStatusDevices(type, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the global hardware support status, i.e. a list of End-of-Life and End-of-Sale dates with the corresponding device count.
     * @summary Get the global hardware support status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getHardwareSupportStats(options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getHardwareSupportStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of compliance policies.
     * @summary Get the compliance policies
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getPolicies(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getPolicies(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the rules owned by a given compliance policy.
     * @summary Get the compliance rules of a policy
     * @param {number} id Policy ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getPolicyRules(id: number, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getPolicyRules(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of software compliance rules.
     * @summary Get the software compliance rules
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getSoftwareRules(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getSoftwareRules(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits an hardware compliance rule, by ID.
     * @summary Update an hardware compliance rule
     * @param {number} id Hardware rule ID
     * @param {RsHardwareRuleRestApiView} [rsHardwareRuleRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public setHardwareRule(id: number, rsHardwareRuleRestApiView?: RsHardwareRuleRestApiView, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).setHardwareRule(id, rsHardwareRuleRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a compliance policy, by ID.
     * @summary Update a compliance policy
     * @param {number} id Policy ID
     * @param {RsPolicyRestApiView} [rsPolicyRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public setPolicy(id: number, rsPolicyRestApiView?: RsPolicyRestApiView, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).setPolicy(id, rsPolicyRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a compliance rule, by ID.
     * @summary Update a compliance rule
     * @param {number} id Rule ID
     * @param {RsRuleRestApiView} [rsRuleRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public setRule(id: number, rsRuleRestApiView?: RsRuleRestApiView, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).setRule(id, rsRuleRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a software compliance rule.
     * @summary Update a software compliance rule
     * @param {number} id Software rule ID
     * @param {RsSoftwareRuleRestApiView} [rsSoftwareRuleRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public setSoftwareRule(id: number, rsSoftwareRuleRestApiView?: RsSoftwareRuleRestApiView, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).setSoftwareRule(id, rsSoftwareRuleRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test a compliance rule against a given device, in dry run mode.
     * @summary Test a compliance rule
     * @param {RsRuleTestRestApiView} [rsRuleTestRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public testRule(rsRuleTestRestApiView?: RsRuleTestRestApiView, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).testRule(rsRuleTestRestApiView, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * In auto discovery mode, this will create a \'discover device\' task, and the device will be create if the discovery is successful. Otherwise, the device will be immediately created in the database, and a \'snapshot\' task will be created.
         * @summary Add a device
         * @param {RsNewDeviceRestApiView} [rsNewDeviceRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDevice: async (rsNewDeviceRestApiView?: RsNewDeviceRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsNewDeviceRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a device group. A group can be either static (fixed list) or dynamic (query-based list).
         * @summary Add a device group
         * @param {DeviceGroupRestApiView} [deviceGroupRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroup: async (deviceGroupRestApiView?: DeviceGroupRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceGroupRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the given device, by ID.
         * @summary Remove a device
         * @param {number} id Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDevice', 'id', id)
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a device group. This doesn\'t remove the devices themselves.
         * @summary Remove a device group
         * @param {number} id Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of configurations, based on given criteria.
         * @summary Get configuration changes
         * @param {number} [after] Configs gathered after this date (as milliseconds since 1970)
         * @param {number} [before] Configs gathered before this date (as milliseconds since 1970)
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigs: async (after?: number, before?: number, domain?: Set<number>, group?: Set<number>, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }

            if (group) {
                localVarQueryParameter['group'] = Array.from(group);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a device will all details.
         * @summary Get a device
         * @param {number} id Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDevice', 'id', id)
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the compliance results for a give device, by ID.
         * @summary Get the compliance results for a device
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceComplianceResults: async (id: number, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeviceComplianceResults', 'id', id)
            const localVarPath = `/devices/{id}/complianceresults`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the differences between two given device configuration objets, identified by full IDs.
         * @summary Get the diff between two configuration objects
         * @param {number} id1 First config ID
         * @param {number} id2 Second config ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceConfigDiff: async (id1: number, id2: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id1' is not null or undefined
            assertParamExists('getDeviceConfigDiff', 'id1', id1)
            // verify required parameter 'id2' is not null or undefined
            assertParamExists('getDeviceConfigDiff', 'id2', id2)
            const localVarPath = `/configs/{id1}/vs/{id2}`
                .replace(`{${"id1"}}`, encodeURIComponent(String(id1)))
                .replace(`{${"id2"}}`, encodeURIComponent(String(id2)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a device configuration item, in plain text.
         * @summary Get a device configuration item
         * @param {number} id Config ID
         * @param {string} item Config item name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceConfigPlain: async (id: number, item: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeviceConfigPlain', 'id', id)
            // verify required parameter 'item' is not null or undefined
            assertParamExists('getDeviceConfigPlain', 'item', item)
            const localVarPath = `/configs/{id}/{item}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"item"}}`, encodeURIComponent(String(item)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of configurations of the given device, by ID.
         * @summary Get device configs
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceConfigs: async (id: number, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeviceConfigs', 'id', id)
            const localVarPath = `/devices/{id}/configs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the results of a given diagnostic, by ID.
         * @summary Get diagnostic results
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceDiagnosticResults: async (id: number, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeviceDiagnosticResults', 'id', id)
            const localVarPath = `/devices/{id}/diagnosticresults`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of device families (driver specific) currenly known in the database.
         * @summary Get the existing device families
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceFamilies: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devicefamilies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of interfaces of a given device (by ID).
         * @summary Get device interfaces
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceInterfaces: async (id: number, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeviceInterfaces', 'id', id)
            const localVarPath = `/devices/{id}/interfaces`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of hardware modules of a given device, by ID.
         * @summary Get device modules
         * @param {number} id Device ID
         * @param {boolean} [history] Whether to include history (removed modules with dates)
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceModules: async (id: number, history?: boolean, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeviceModules', 'id', id)
            const localVarPath = `/devices/{id}/modules`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (history !== undefined) {
                localVarQueryParameter['history'] = history;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of tasks of a given device (by ID). Tasks are returned sorted by status and significant date.
         * @summary Get device tasks
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceTasks: async (id: number, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeviceTasks', 'id', id)
            const localVarPath = `/devices/{id}/tasks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the device list with minimal details.
         * @summary Get the devices
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [group] Filter on devices of the given group ID
         * @param {boolean} [details] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices: async (offset?: number, limit?: number, group?: number, details?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (details !== undefined) {
                localVarQueryParameter['details'] = details;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of device groups, including their definition.
         * @summary Get the device groups
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of all known part numbers currently existing in the module table.
         * @summary Get the known part numbers
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartNumbers: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/partnumbers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find devices using a string-based query.
         * @summary Search for devices
         * @param {RsSearchCriteriaRestApiView} [rsSearchCriteriaRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDevices: async (rsSearchCriteriaRestApiView?: RsSearchCriteriaRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/devices/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsSearchCriteriaRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a device, by ID.
         * @summary Update a device
         * @param {number} id Device ID
         * @param {RsDeviceRestApiView} [rsDeviceRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDevice: async (id: number, rsDeviceRestApiView?: RsDeviceRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setDevice', 'id', id)
            const localVarPath = `/devices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsDeviceRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a device group, by ID.
         * @summary Update a device group
         * @param {number} id Group ID
         * @param {RsDeviceGroupRestApiView} [rsDeviceGroupRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGroup: async (id: number, rsDeviceGroupRestApiView?: RsDeviceGroupRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsDeviceGroupRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * In auto discovery mode, this will create a \'discover device\' task, and the device will be create if the discovery is successful. Otherwise, the device will be immediately created in the database, and a \'snapshot\' task will be created.
         * @summary Add a device
         * @param {RsNewDeviceRestApiView} [rsNewDeviceRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDevice(rsNewDeviceRestApiView?: RsNewDeviceRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDevice(rsNewDeviceRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a device group. A group can be either static (fixed list) or dynamic (query-based list).
         * @summary Add a device group
         * @param {DeviceGroupRestApiView} [deviceGroupRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addGroup(deviceGroupRestApiView?: DeviceGroupRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceGroupRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addGroup(deviceGroupRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove the given device, by ID.
         * @summary Remove a device
         * @param {number} id Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDevice(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a device group. This doesn\'t remove the devices themselves.
         * @summary Remove a device group
         * @param {number} id Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of configurations, based on given criteria.
         * @summary Get configuration changes
         * @param {number} [after] Configs gathered after this date (as milliseconds since 1970)
         * @param {number} [before] Configs gathered before this date (as milliseconds since 1970)
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigs(after?: number, before?: number, domain?: Set<number>, group?: Set<number>, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsLightConfigRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigs(after, before, domain, group, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a device will all details.
         * @summary Get a device
         * @param {number} id Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevice(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevice(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the compliance results for a give device, by ID.
         * @summary Get the compliance results for a device
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceComplianceResults(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsDeviceRuleRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceComplianceResults(id, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the differences between two given device configuration objets, identified by full IDs.
         * @summary Get the diff between two configuration objects
         * @param {number} id1 First config ID
         * @param {number} id2 Second config ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceConfigDiff(id1: number, id2: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RsConfigDiffRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceConfigDiff(id1, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a device configuration item, in plain text.
         * @summary Get a device configuration item
         * @param {number} id Config ID
         * @param {string} item Config item name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceConfigPlain(id: number, item: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceConfigPlain(id, item, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of configurations of the given device, by ID.
         * @summary Get device configs
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceConfigs(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConfigRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceConfigs(id, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the results of a given diagnostic, by ID.
         * @summary Get diagnostic results
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceDiagnosticResults(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiagnosticResultRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceDiagnosticResults(id, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of device families (driver specific) currenly known in the database.
         * @summary Get the existing device families
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceFamilies(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsDeviceFamilyRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceFamilies(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of interfaces of a given device (by ID).
         * @summary Get device interfaces
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceInterfaces(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkInterfaceRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceInterfaces(id, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of hardware modules of a given device, by ID.
         * @summary Get device modules
         * @param {number} id Device ID
         * @param {boolean} [history] Whether to include history (removed modules with dates)
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceModules(id: number, history?: boolean, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModuleRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceModules(id, history, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of tasks of a given device (by ID). Tasks are returned sorted by status and significant date.
         * @summary Get device tasks
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceTasks(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceTasks(id, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the device list with minimal details.
         * @summary Get the devices
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [group] Filter on devices of the given group ID
         * @param {boolean} [details] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDevices(offset?: number, limit?: number, group?: number, details?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsLightDeviceRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDevices(offset, limit, group, details, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of device groups, including their definition.
         * @summary Get the device groups
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroups(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceGroupRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroups(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of all known part numbers currently existing in the module table.
         * @summary Get the known part numbers
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartNumbers(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsPartNumberRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartNumbers(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find devices using a string-based query.
         * @summary Search for devices
         * @param {RsSearchCriteriaRestApiView} [rsSearchCriteriaRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDevices(rsSearchCriteriaRestApiView?: RsSearchCriteriaRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RsSearchResultsRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDevices(rsSearchCriteriaRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a device, by ID.
         * @summary Update a device
         * @param {number} id Device ID
         * @param {RsDeviceRestApiView} [rsDeviceRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDevice(id: number, rsDeviceRestApiView?: RsDeviceRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDevice(id, rsDeviceRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a device group, by ID.
         * @summary Update a device group
         * @param {number} id Group ID
         * @param {RsDeviceGroupRestApiView} [rsDeviceGroupRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setGroup(id: number, rsDeviceGroupRestApiView?: RsDeviceGroupRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceGroupRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setGroup(id, rsDeviceGroupRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * In auto discovery mode, this will create a \'discover device\' task, and the device will be create if the discovery is successful. Otherwise, the device will be immediately created in the database, and a \'snapshot\' task will be created.
         * @summary Add a device
         * @param {RsNewDeviceRestApiView} [rsNewDeviceRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDevice(rsNewDeviceRestApiView?: RsNewDeviceRestApiView, options?: any): AxiosPromise<TaskRestApiView> {
            return localVarFp.addDevice(rsNewDeviceRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a device group. A group can be either static (fixed list) or dynamic (query-based list).
         * @summary Add a device group
         * @param {DeviceGroupRestApiView} [deviceGroupRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addGroup(deviceGroupRestApiView?: DeviceGroupRestApiView, options?: any): AxiosPromise<DeviceGroupRestApiView> {
            return localVarFp.addGroup(deviceGroupRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the given device, by ID.
         * @summary Remove a device
         * @param {number} id Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDevice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a device group. This doesn\'t remove the devices themselves.
         * @summary Remove a device group
         * @param {number} id Group ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of configurations, based on given criteria.
         * @summary Get configuration changes
         * @param {number} [after] Configs gathered after this date (as milliseconds since 1970)
         * @param {number} [before] Configs gathered before this date (as milliseconds since 1970)
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigs(after?: number, before?: number, domain?: Set<number>, group?: Set<number>, offset?: number, limit?: number, options?: any): AxiosPromise<Array<RsLightConfigRestApiView>> {
            return localVarFp.getConfigs(after, before, domain, group, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a device will all details.
         * @summary Get a device
         * @param {number} id Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevice(id: number, options?: any): AxiosPromise<DeviceRestApiView> {
            return localVarFp.getDevice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the compliance results for a give device, by ID.
         * @summary Get the compliance results for a device
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceComplianceResults(id: number, offset?: number, limit?: number, options?: any): AxiosPromise<Array<RsDeviceRuleRestApiView>> {
            return localVarFp.getDeviceComplianceResults(id, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the differences between two given device configuration objets, identified by full IDs.
         * @summary Get the diff between two configuration objects
         * @param {number} id1 First config ID
         * @param {number} id2 Second config ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceConfigDiff(id1: number, id2: number, options?: any): AxiosPromise<RsConfigDiffRestApiView> {
            return localVarFp.getDeviceConfigDiff(id1, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a device configuration item, in plain text.
         * @summary Get a device configuration item
         * @param {number} id Config ID
         * @param {string} item Config item name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceConfigPlain(id: number, item: string, options?: any): AxiosPromise<void> {
            return localVarFp.getDeviceConfigPlain(id, item, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of configurations of the given device, by ID.
         * @summary Get device configs
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceConfigs(id: number, offset?: number, limit?: number, options?: any): AxiosPromise<Array<ConfigRestApiView>> {
            return localVarFp.getDeviceConfigs(id, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the results of a given diagnostic, by ID.
         * @summary Get diagnostic results
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceDiagnosticResults(id: number, offset?: number, limit?: number, options?: any): AxiosPromise<Array<DiagnosticResultRestApiView>> {
            return localVarFp.getDeviceDiagnosticResults(id, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of device families (driver specific) currenly known in the database.
         * @summary Get the existing device families
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceFamilies(offset?: number, limit?: number, options?: any): AxiosPromise<Array<RsDeviceFamilyRestApiView>> {
            return localVarFp.getDeviceFamilies(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of interfaces of a given device (by ID).
         * @summary Get device interfaces
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceInterfaces(id: number, offset?: number, limit?: number, options?: any): AxiosPromise<Array<NetworkInterfaceRestApiView>> {
            return localVarFp.getDeviceInterfaces(id, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of hardware modules of a given device, by ID.
         * @summary Get device modules
         * @param {number} id Device ID
         * @param {boolean} [history] Whether to include history (removed modules with dates)
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceModules(id: number, history?: boolean, offset?: number, limit?: number, options?: any): AxiosPromise<Array<ModuleRestApiView>> {
            return localVarFp.getDeviceModules(id, history, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of tasks of a given device (by ID). Tasks are returned sorted by status and significant date.
         * @summary Get device tasks
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceTasks(id: number, offset?: number, limit?: number, options?: any): AxiosPromise<Array<TaskRestApiView>> {
            return localVarFp.getDeviceTasks(id, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the device list with minimal details.
         * @summary Get the devices
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {number} [group] Filter on devices of the given group ID
         * @param {boolean} [details] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDevices(offset?: number, limit?: number, group?: number, details?: boolean, options?: any): AxiosPromise<Array<RsLightDeviceRestApiView>> {
            return localVarFp.getDevices(offset, limit, group, details, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of device groups, including their definition.
         * @summary Get the device groups
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(offset?: number, limit?: number, options?: any): AxiosPromise<Array<DeviceGroupRestApiView>> {
            return localVarFp.getGroups(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of all known part numbers currently existing in the module table.
         * @summary Get the known part numbers
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartNumbers(offset?: number, limit?: number, options?: any): AxiosPromise<Array<RsPartNumberRestApiView>> {
            return localVarFp.getPartNumbers(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Find devices using a string-based query.
         * @summary Search for devices
         * @param {RsSearchCriteriaRestApiView} [rsSearchCriteriaRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDevices(rsSearchCriteriaRestApiView?: RsSearchCriteriaRestApiView, options?: any): AxiosPromise<RsSearchResultsRestApiView> {
            return localVarFp.searchDevices(rsSearchCriteriaRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a device, by ID.
         * @summary Update a device
         * @param {number} id Device ID
         * @param {RsDeviceRestApiView} [rsDeviceRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDevice(id: number, rsDeviceRestApiView?: RsDeviceRestApiView, options?: any): AxiosPromise<DeviceRestApiView> {
            return localVarFp.setDevice(id, rsDeviceRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a device group, by ID.
         * @summary Update a device group
         * @param {number} id Group ID
         * @param {RsDeviceGroupRestApiView} [rsDeviceGroupRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setGroup(id: number, rsDeviceGroupRestApiView?: RsDeviceGroupRestApiView, options?: any): AxiosPromise<DeviceGroupRestApiView> {
            return localVarFp.setGroup(id, rsDeviceGroupRestApiView, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * In auto discovery mode, this will create a \'discover device\' task, and the device will be create if the discovery is successful. Otherwise, the device will be immediately created in the database, and a \'snapshot\' task will be created.
     * @summary Add a device
     * @param {RsNewDeviceRestApiView} [rsNewDeviceRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public addDevice(rsNewDeviceRestApiView?: RsNewDeviceRestApiView, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).addDevice(rsNewDeviceRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a device group. A group can be either static (fixed list) or dynamic (query-based list).
     * @summary Add a device group
     * @param {DeviceGroupRestApiView} [deviceGroupRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public addGroup(deviceGroupRestApiView?: DeviceGroupRestApiView, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).addGroup(deviceGroupRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the given device, by ID.
     * @summary Remove a device
     * @param {number} id Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteDevice(id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteDevice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a device group. This doesn\'t remove the devices themselves.
     * @summary Remove a device group
     * @param {number} id Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public deleteGroup(id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).deleteGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of configurations, based on given criteria.
     * @summary Get configuration changes
     * @param {number} [after] Configs gathered after this date (as milliseconds since 1970)
     * @param {number} [before] Configs gathered before this date (as milliseconds since 1970)
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {Set<number>} [group] Filter on given group ID(s)
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getConfigs(after?: number, before?: number, domain?: Set<number>, group?: Set<number>, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getConfigs(after, before, domain, group, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a device will all details.
     * @summary Get a device
     * @param {number} id Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevice(id: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the compliance results for a give device, by ID.
     * @summary Get the compliance results for a device
     * @param {number} id Device ID
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceComplianceResults(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDeviceComplianceResults(id, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the differences between two given device configuration objets, identified by full IDs.
     * @summary Get the diff between two configuration objects
     * @param {number} id1 First config ID
     * @param {number} id2 Second config ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceConfigDiff(id1: number, id2: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDeviceConfigDiff(id1, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a device configuration item, in plain text.
     * @summary Get a device configuration item
     * @param {number} id Config ID
     * @param {string} item Config item name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceConfigPlain(id: number, item: string, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDeviceConfigPlain(id, item, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of configurations of the given device, by ID.
     * @summary Get device configs
     * @param {number} id Device ID
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceConfigs(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDeviceConfigs(id, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the results of a given diagnostic, by ID.
     * @summary Get diagnostic results
     * @param {number} id Device ID
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceDiagnosticResults(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDeviceDiagnosticResults(id, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of device families (driver specific) currenly known in the database.
     * @summary Get the existing device families
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceFamilies(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDeviceFamilies(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of interfaces of a given device (by ID).
     * @summary Get device interfaces
     * @param {number} id Device ID
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceInterfaces(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDeviceInterfaces(id, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of hardware modules of a given device, by ID.
     * @summary Get device modules
     * @param {number} id Device ID
     * @param {boolean} [history] Whether to include history (removed modules with dates)
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceModules(id: number, history?: boolean, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDeviceModules(id, history, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of tasks of a given device (by ID). Tasks are returned sorted by status and significant date.
     * @summary Get device tasks
     * @param {number} id Device ID
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDeviceTasks(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDeviceTasks(id, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the device list with minimal details.
     * @summary Get the devices
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {number} [group] Filter on devices of the given group ID
     * @param {boolean} [details] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getDevices(offset?: number, limit?: number, group?: number, details?: boolean, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getDevices(offset, limit, group, details, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of device groups, including their definition.
     * @summary Get the device groups
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getGroups(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getGroups(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of all known part numbers currently existing in the module table.
     * @summary Get the known part numbers
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public getPartNumbers(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).getPartNumbers(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find devices using a string-based query.
     * @summary Search for devices
     * @param {RsSearchCriteriaRestApiView} [rsSearchCriteriaRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public searchDevices(rsSearchCriteriaRestApiView?: RsSearchCriteriaRestApiView, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).searchDevices(rsSearchCriteriaRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a device, by ID.
     * @summary Update a device
     * @param {number} id Device ID
     * @param {RsDeviceRestApiView} [rsDeviceRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public setDevice(id: number, rsDeviceRestApiView?: RsDeviceRestApiView, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).setDevice(id, rsDeviceRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a device group, by ID.
     * @summary Update a device group
     * @param {number} id Group ID
     * @param {RsDeviceGroupRestApiView} [rsDeviceGroupRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public setGroup(id: number, rsDeviceGroupRestApiView?: RsDeviceGroupRestApiView, options?: AxiosRequestConfig) {
        return DevicesApiFp(this.configuration).setGroup(id, rsDeviceGroupRestApiView, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiagnosticsApi - axios parameter creator
 * @export
 */
export const DiagnosticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a diagnostic.
         * @summary Add a diagnostic.
         * @param {RsDiagnosticRestApiView} [rsDiagnosticRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDiagnostic: async (rsDiagnosticRestApiView?: RsDiagnosticRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/diagnostics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsDiagnosticRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a given diagnostic, by ID.
         * @summary Remove a diagnostic
         * @param {number} id Diagnostic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiagnostic: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDiagnostic', 'id', id)
            const localVarPath = `/diagnostics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the results of a given diagnostic, by ID.
         * @summary Get diagnostic results
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceDiagnosticResults: async (id: number, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeviceDiagnosticResults', 'id', id)
            const localVarPath = `/devices/{id}/diagnosticresults`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of diagnostics.
         * @summary Get the diagnostics
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiagnostics: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/diagnostics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new diagnostic.
         * @summary Update a diagnostic
         * @param {number} id Diagnostic ID
         * @param {RsDiagnosticRestApiView} [rsDiagnosticRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDiagnostic: async (id: number, rsDiagnosticRestApiView?: RsDiagnosticRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setDiagnostic', 'id', id)
            const localVarPath = `/diagnostics/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsDiagnosticRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiagnosticsApi - functional programming interface
 * @export
 */
export const DiagnosticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiagnosticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a diagnostic.
         * @summary Add a diagnostic.
         * @param {RsDiagnosticRestApiView} [rsDiagnosticRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDiagnostic(rsDiagnosticRestApiView?: RsDiagnosticRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiagnosticRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDiagnostic(rsDiagnosticRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a given diagnostic, by ID.
         * @summary Remove a diagnostic
         * @param {number} id Diagnostic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiagnostic(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDiagnostic(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the results of a given diagnostic, by ID.
         * @summary Get diagnostic results
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceDiagnosticResults(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiagnosticResultRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceDiagnosticResults(id, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of diagnostics.
         * @summary Get the diagnostics
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiagnostics(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DiagnosticRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiagnostics(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new diagnostic.
         * @summary Update a diagnostic
         * @param {number} id Diagnostic ID
         * @param {RsDiagnosticRestApiView} [rsDiagnosticRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDiagnostic(id: number, rsDiagnosticRestApiView?: RsDiagnosticRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiagnosticRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDiagnostic(id, rsDiagnosticRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiagnosticsApi - factory interface
 * @export
 */
export const DiagnosticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiagnosticsApiFp(configuration)
    return {
        /**
         * Creates a diagnostic.
         * @summary Add a diagnostic.
         * @param {RsDiagnosticRestApiView} [rsDiagnosticRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDiagnostic(rsDiagnosticRestApiView?: RsDiagnosticRestApiView, options?: any): AxiosPromise<DiagnosticRestApiView> {
            return localVarFp.addDiagnostic(rsDiagnosticRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a given diagnostic, by ID.
         * @summary Remove a diagnostic
         * @param {number} id Diagnostic ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiagnostic(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDiagnostic(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the results of a given diagnostic, by ID.
         * @summary Get diagnostic results
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceDiagnosticResults(id: number, offset?: number, limit?: number, options?: any): AxiosPromise<Array<DiagnosticResultRestApiView>> {
            return localVarFp.getDeviceDiagnosticResults(id, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of diagnostics.
         * @summary Get the diagnostics
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiagnostics(offset?: number, limit?: number, options?: any): AxiosPromise<Array<DiagnosticRestApiView>> {
            return localVarFp.getDiagnostics(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new diagnostic.
         * @summary Update a diagnostic
         * @param {number} id Diagnostic ID
         * @param {RsDiagnosticRestApiView} [rsDiagnosticRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDiagnostic(id: number, rsDiagnosticRestApiView?: RsDiagnosticRestApiView, options?: any): AxiosPromise<DiagnosticRestApiView> {
            return localVarFp.setDiagnostic(id, rsDiagnosticRestApiView, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiagnosticsApi - object-oriented interface
 * @export
 * @class DiagnosticsApi
 * @extends {BaseAPI}
 */
export class DiagnosticsApi extends BaseAPI {
    /**
     * Creates a diagnostic.
     * @summary Add a diagnostic.
     * @param {RsDiagnosticRestApiView} [rsDiagnosticRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticsApi
     */
    public addDiagnostic(rsDiagnosticRestApiView?: RsDiagnosticRestApiView, options?: AxiosRequestConfig) {
        return DiagnosticsApiFp(this.configuration).addDiagnostic(rsDiagnosticRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a given diagnostic, by ID.
     * @summary Remove a diagnostic
     * @param {number} id Diagnostic ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticsApi
     */
    public deleteDiagnostic(id: number, options?: AxiosRequestConfig) {
        return DiagnosticsApiFp(this.configuration).deleteDiagnostic(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the results of a given diagnostic, by ID.
     * @summary Get diagnostic results
     * @param {number} id Device ID
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticsApi
     */
    public getDeviceDiagnosticResults(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DiagnosticsApiFp(this.configuration).getDeviceDiagnosticResults(id, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of diagnostics.
     * @summary Get the diagnostics
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticsApi
     */
    public getDiagnostics(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return DiagnosticsApiFp(this.configuration).getDiagnostics(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new diagnostic.
     * @summary Update a diagnostic
     * @param {number} id Diagnostic ID
     * @param {RsDiagnosticRestApiView} [rsDiagnosticRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiagnosticsApi
     */
    public setDiagnostic(id: number, rsDiagnosticRestApiView?: RsDiagnosticRestApiView, options?: AxiosRequestConfig) {
        return DiagnosticsApiFp(this.configuration).setDiagnostic(id, rsDiagnosticRestApiView, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the current logged in user.
         * @summary Get the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs in (create session) by username and password (useless when using API tokens).
         * @summary Log in
         * @param {RsLoginRestApiView} [rsLoginRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (rsLoginRestApiView?: RsLoginRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsLoginRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminates the current user session (useless when using API tokens).
         * @summary User log out
         * @param {number} id User ID - not used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logout', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a given user, by ID, especially the password for a local user.
         * @summary Update a user
         * @param {number} id User ID
         * @param {RsLoginRestApiView} [rsLoginRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPassword: async (id: number, rsLoginRestApiView?: RsLoginRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setPassword', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsLoginRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoginApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the current logged in user.
         * @summary Get the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UiUserRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Logs in (create session) by username and password (useless when using API tokens).
         * @summary Log in
         * @param {RsLoginRestApiView} [rsLoginRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(rsLoginRestApiView?: RsLoginRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UiUserRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(rsLoginRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Terminates the current user session (useless when using API tokens).
         * @summary User log out
         * @param {number} id User ID - not used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a given user, by ID, especially the password for a local user.
         * @summary Update a user
         * @param {number} id User ID
         * @param {RsLoginRestApiView} [rsLoginRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPassword(id: number, rsLoginRestApiView?: RsLoginRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UiUserRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPassword(id, rsLoginRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoginApiFp(configuration)
    return {
        /**
         * Returns the current logged in user.
         * @summary Get the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: any): AxiosPromise<UiUserRestApiView> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Logs in (create session) by username and password (useless when using API tokens).
         * @summary Log in
         * @param {RsLoginRestApiView} [rsLoginRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(rsLoginRestApiView?: RsLoginRestApiView, options?: any): AxiosPromise<UiUserRestApiView> {
            return localVarFp.login(rsLoginRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminates the current user session (useless when using API tokens).
         * @summary User log out
         * @param {number} id User ID - not used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.logout(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a given user, by ID, especially the password for a local user.
         * @summary Update a user
         * @param {number} id User ID
         * @param {RsLoginRestApiView} [rsLoginRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPassword(id: number, rsLoginRestApiView?: RsLoginRestApiView, options?: any): AxiosPromise<UiUserRestApiView> {
            return localVarFp.setPassword(id, rsLoginRestApiView, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
    /**
     * Returns the current logged in user.
     * @summary Get the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public getUser(options?: AxiosRequestConfig) {
        return LoginApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs in (create session) by username and password (useless when using API tokens).
     * @summary Log in
     * @param {RsLoginRestApiView} [rsLoginRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public login(rsLoginRestApiView?: RsLoginRestApiView, options?: AxiosRequestConfig) {
        return LoginApiFp(this.configuration).login(rsLoginRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminates the current user session (useless when using API tokens).
     * @summary User log out
     * @param {number} id User ID - not used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public logout(id: number, options?: AxiosRequestConfig) {
        return LoginApiFp(this.configuration).logout(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a given user, by ID, especially the password for a local user.
     * @summary Update a user
     * @param {number} id User ID
     * @param {RsLoginRestApiView} [rsLoginRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public setPassword(id: number, rsLoginRestApiView?: RsLoginRestApiView, options?: AxiosRequestConfig) {
        return LoginApiFp(this.configuration).setPassword(id, rsLoginRestApiView, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the list of devices which didn\'t have a successful snapshot over the given number of days, optionally filtered by device domain.
         * @summary Get the devices without successful snapshot over a given period
         * @param {number} [days] Look for the given number of last days
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessFailureDevices: async (days?: number, domain?: Set<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/accessfailuredevices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (days !== undefined) {
                localVarQueryParameter['days'] = days;
            }

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the configuration compliance status of devices; optionally filtered by domain, group, policy or compliance level.
         * @summary Get the configuration compliance status of devices
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>} [result] Filter on given result(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigComplianceDeviceStatuses: async (domain?: Set<number>, group?: Set<number>, policy?: Set<number>, result?: Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/configcompliancedevicestatuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }

            if (group) {
                localVarQueryParameter['group'] = Array.from(group);
            }

            if (policy) {
                localVarQueryParameter['policy'] = Array.from(policy);
            }

            if (result) {
                localVarQueryParameter['result'] = Array.from(result);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of configurations, based on given criteria.
         * @summary Get configuration changes
         * @param {number} [after] Configs gathered after this date (as milliseconds since 1970)
         * @param {number} [before] Configs gathered before this date (as milliseconds since 1970)
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigs: async (after?: number, before?: number, domain?: Set<number>, group?: Set<number>, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }

            if (group) {
                localVarQueryParameter['group'] = Array.from(group);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports data as Excel datasheet. The devices can be filtered by groups or domains. The report can be customized to include or not interfaces, inventory, locations, compliance, groups. The only supported and default output format is xlsx (Excel file).
         * @summary Export data
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {boolean} [interfaces] Whether to export interface data
         * @param {boolean} [inventory] Whether to export inventory data
         * @param {boolean} [inventoryhistory] Whether to export interface history
         * @param {boolean} [locations] Whether to export locations
         * @param {boolean} [compliance] Whether to export compliance results
         * @param {boolean} [groups] Whether to export group info
         * @param {string} [format] Export format (xlsx is supported)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataXLSX: async (group?: Set<number>, domain?: Set<number>, interfaces?: boolean, inventory?: boolean, inventoryhistory?: boolean, locations?: boolean, compliance?: boolean, groups?: boolean, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (group) {
                localVarQueryParameter['group'] = Array.from(group);
            }

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }

            if (interfaces !== undefined) {
                localVarQueryParameter['interfaces'] = interfaces;
            }

            if (inventory !== undefined) {
                localVarQueryParameter['inventory'] = inventory;
            }

            if (inventoryhistory !== undefined) {
                localVarQueryParameter['inventoryhistory'] = inventoryhistory;
            }

            if (locations !== undefined) {
                localVarQueryParameter['locations'] = locations;
            }

            if (compliance !== undefined) {
                localVarQueryParameter['compliance'] = compliance;
            }

            if (groups !== undefined) {
                localVarQueryParameter['groups'] = groups;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the compliance status of a given device group, by ID.
         * @summary Get the compliance status of a device group
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupConfigComplianceStats: async (domain?: Set<number>, group?: Set<number>, policy?: Set<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/groupconfigcompliancestats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }

            if (group) {
                localVarQueryParameter['group'] = Array.from(group);
            }

            if (policy) {
                localVarQueryParameter['policy'] = Array.from(policy);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of non-compliance devices part of a given group, optionally filtered by domains and policies
         * @summary Get the non compliant devices of a group
         * @param {number} id Group ID
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupConfigNonCompliantDevices: async (id: number, domain?: Set<number>, policy?: Set<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupConfigNonCompliantDevices', 'id', id)
            const localVarPath = `/reports/groupconfignoncompliantdevices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }

            if (policy) {
                localVarQueryParameter['policy'] = Array.from(policy);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of devices of a given group by ID, and matching the given software compliance level.
         * @summary Get the devices of a group based on software compliance level
         * @param {number} id Group ID
         * @param {string} level Software compliance level
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupDevicesBySoftwareLevel: async (id: number, level: string, domain?: Set<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGroupDevicesBySoftwareLevel', 'id', id)
            // verify required parameter 'level' is not null or undefined
            assertParamExists('getGroupDevicesBySoftwareLevel', 'level', level)
            const localVarPath = `/reports/groupdevicesbysoftwarelevel/{id}/{level}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"level"}}`, encodeURIComponent(String(level)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the software compliance status of devices, optionally filtered by a list of device domains.
         * @summary Get the global software compliance status
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupSoftwareComplianceStats: async (domain?: Set<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/groupsoftwarecompliancestats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (domain) {
                localVarQueryParameter['domain'] = Array.from(domain);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of devices getting End-of-Life (type \'eol\') or End-of-Sale (type \'eos\') at the given date (or never if \'date\' is not given).
         * @summary Get the End-of-Life or End-of-Sale devices matching a date.
         * @param {string} type eos (end-of-sale) or eol (end-of-life), type of date
         * @param {number} date EoX date to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardwareStatusDevices: async (type: string, date: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getHardwareStatusDevices', 'type', type)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getHardwareStatusDevices', 'date', date)
            const localVarPath = `/reports/hardwaresupportdevices/{type}/{date}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the global hardware support status, i.e. a list of End-of-Life and End-of-Sale dates with the corresponding device count.
         * @summary Get the global hardware support status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardwareSupportStats: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/hardwaresupportstats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the list of devices which didn\'t have a successful snapshot over the given number of days, optionally filtered by device domain.
         * @summary Get the devices without successful snapshot over a given period
         * @param {number} [days] Look for the given number of last days
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessFailureDevices(days?: number, domain?: Set<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsLightAccessFailureDeviceRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessFailureDevices(days, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the configuration compliance status of devices; optionally filtered by domain, group, policy or compliance level.
         * @summary Get the configuration compliance status of devices
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>} [result] Filter on given result(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigComplianceDeviceStatuses(domain?: Set<number>, group?: Set<number>, policy?: Set<number>, result?: Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsLightPolicyRuleDeviceRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigComplianceDeviceStatuses(domain, group, policy, result, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves a list of configurations, based on given criteria.
         * @summary Get configuration changes
         * @param {number} [after] Configs gathered after this date (as milliseconds since 1970)
         * @param {number} [before] Configs gathered before this date (as milliseconds since 1970)
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigs(after?: number, before?: number, domain?: Set<number>, group?: Set<number>, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsLightConfigRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigs(after, before, domain, group, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Exports data as Excel datasheet. The devices can be filtered by groups or domains. The report can be customized to include or not interfaces, inventory, locations, compliance, groups. The only supported and default output format is xlsx (Excel file).
         * @summary Export data
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {boolean} [interfaces] Whether to export interface data
         * @param {boolean} [inventory] Whether to export inventory data
         * @param {boolean} [inventoryhistory] Whether to export interface history
         * @param {boolean} [locations] Whether to export locations
         * @param {boolean} [compliance] Whether to export compliance results
         * @param {boolean} [groups] Whether to export group info
         * @param {string} [format] Export format (xlsx is supported)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataXLSX(group?: Set<number>, domain?: Set<number>, interfaces?: boolean, inventory?: boolean, inventoryhistory?: boolean, locations?: boolean, compliance?: boolean, groups?: boolean, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataXLSX(group, domain, interfaces, inventory, inventoryhistory, locations, compliance, groups, format, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the compliance status of a given device group, by ID.
         * @summary Get the compliance status of a device group
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupConfigComplianceStats(domain?: Set<number>, group?: Set<number>, policy?: Set<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsGroupConfigComplianceStatRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupConfigComplianceStats(domain, group, policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of non-compliance devices part of a given group, optionally filtered by domains and policies
         * @summary Get the non compliant devices of a group
         * @param {number} id Group ID
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupConfigNonCompliantDevices(id: number, domain?: Set<number>, policy?: Set<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsLightPolicyRuleDeviceRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupConfigNonCompliantDevices(id, domain, policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of devices of a given group by ID, and matching the given software compliance level.
         * @summary Get the devices of a group based on software compliance level
         * @param {number} id Group ID
         * @param {string} level Software compliance level
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupDevicesBySoftwareLevel(id: number, level: string, domain?: Set<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsLightSoftwareLevelDeviceRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupDevicesBySoftwareLevel(id, level, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the software compliance status of devices, optionally filtered by a list of device domains.
         * @summary Get the global software compliance status
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupSoftwareComplianceStats(domain?: Set<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsGroupSoftwareComplianceStatRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupSoftwareComplianceStats(domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of devices getting End-of-Life (type \'eol\') or End-of-Sale (type \'eos\') at the given date (or never if \'date\' is not given).
         * @summary Get the End-of-Life or End-of-Sale devices matching a date.
         * @param {string} type eos (end-of-sale) or eol (end-of-life), type of date
         * @param {number} date EoX date to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHardwareStatusDevices(type: string, date: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsLightDeviceRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHardwareStatusDevices(type, date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the global hardware support status, i.e. a list of End-of-Life and End-of-Sale dates with the corresponding device count.
         * @summary Get the global hardware support status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHardwareSupportStats(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RsHardwareSupportStatRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHardwareSupportStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * Returns the list of devices which didn\'t have a successful snapshot over the given number of days, optionally filtered by device domain.
         * @summary Get the devices without successful snapshot over a given period
         * @param {number} [days] Look for the given number of last days
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessFailureDevices(days?: number, domain?: Set<number>, options?: any): AxiosPromise<Array<RsLightAccessFailureDeviceRestApiView>> {
            return localVarFp.getAccessFailureDevices(days, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the configuration compliance status of devices; optionally filtered by domain, group, policy or compliance level.
         * @summary Get the configuration compliance status of devices
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>} [result] Filter on given result(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigComplianceDeviceStatuses(domain?: Set<number>, group?: Set<number>, policy?: Set<number>, result?: Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>, options?: any): AxiosPromise<Array<RsLightPolicyRuleDeviceRestApiView>> {
            return localVarFp.getConfigComplianceDeviceStatuses(domain, group, policy, result, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of configurations, based on given criteria.
         * @summary Get configuration changes
         * @param {number} [after] Configs gathered after this date (as milliseconds since 1970)
         * @param {number} [before] Configs gathered before this date (as milliseconds since 1970)
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigs(after?: number, before?: number, domain?: Set<number>, group?: Set<number>, offset?: number, limit?: number, options?: any): AxiosPromise<Array<RsLightConfigRestApiView>> {
            return localVarFp.getConfigs(after, before, domain, group, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Exports data as Excel datasheet. The devices can be filtered by groups or domains. The report can be customized to include or not interfaces, inventory, locations, compliance, groups. The only supported and default output format is xlsx (Excel file).
         * @summary Export data
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {boolean} [interfaces] Whether to export interface data
         * @param {boolean} [inventory] Whether to export inventory data
         * @param {boolean} [inventoryhistory] Whether to export interface history
         * @param {boolean} [locations] Whether to export locations
         * @param {boolean} [compliance] Whether to export compliance results
         * @param {boolean} [groups] Whether to export group info
         * @param {string} [format] Export format (xlsx is supported)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataXLSX(group?: Set<number>, domain?: Set<number>, interfaces?: boolean, inventory?: boolean, inventoryhistory?: boolean, locations?: boolean, compliance?: boolean, groups?: boolean, format?: string, options?: any): AxiosPromise<void> {
            return localVarFp.getDataXLSX(group, domain, interfaces, inventory, inventoryhistory, locations, compliance, groups, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the compliance status of a given device group, by ID.
         * @summary Get the compliance status of a device group
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [group] Filter on given group ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupConfigComplianceStats(domain?: Set<number>, group?: Set<number>, policy?: Set<number>, options?: any): AxiosPromise<Array<RsGroupConfigComplianceStatRestApiView>> {
            return localVarFp.getGroupConfigComplianceStats(domain, group, policy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of non-compliance devices part of a given group, optionally filtered by domains and policies
         * @summary Get the non compliant devices of a group
         * @param {number} id Group ID
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {Set<number>} [policy] Filter on given policy ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupConfigNonCompliantDevices(id: number, domain?: Set<number>, policy?: Set<number>, options?: any): AxiosPromise<Array<RsLightPolicyRuleDeviceRestApiView>> {
            return localVarFp.getGroupConfigNonCompliantDevices(id, domain, policy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of devices of a given group by ID, and matching the given software compliance level.
         * @summary Get the devices of a group based on software compliance level
         * @param {number} id Group ID
         * @param {string} level Software compliance level
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupDevicesBySoftwareLevel(id: number, level: string, domain?: Set<number>, options?: any): AxiosPromise<Array<RsLightSoftwareLevelDeviceRestApiView>> {
            return localVarFp.getGroupDevicesBySoftwareLevel(id, level, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the software compliance status of devices, optionally filtered by a list of device domains.
         * @summary Get the global software compliance status
         * @param {Set<number>} [domain] Filter on given domain ID(s)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupSoftwareComplianceStats(domain?: Set<number>, options?: any): AxiosPromise<Array<RsGroupSoftwareComplianceStatRestApiView>> {
            return localVarFp.getGroupSoftwareComplianceStats(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of devices getting End-of-Life (type \'eol\') or End-of-Sale (type \'eos\') at the given date (or never if \'date\' is not given).
         * @summary Get the End-of-Life or End-of-Sale devices matching a date.
         * @param {string} type eos (end-of-sale) or eol (end-of-life), type of date
         * @param {number} date EoX date to filter on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardwareStatusDevices(type: string, date: number, options?: any): AxiosPromise<Array<RsLightDeviceRestApiView>> {
            return localVarFp.getHardwareStatusDevices(type, date, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the global hardware support status, i.e. a list of End-of-Life and End-of-Sale dates with the corresponding device count.
         * @summary Get the global hardware support status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHardwareSupportStats(options?: any): AxiosPromise<Array<RsHardwareSupportStatRestApiView>> {
            return localVarFp.getHardwareSupportStats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * Returns the list of devices which didn\'t have a successful snapshot over the given number of days, optionally filtered by device domain.
     * @summary Get the devices without successful snapshot over a given period
     * @param {number} [days] Look for the given number of last days
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getAccessFailureDevices(days?: number, domain?: Set<number>, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getAccessFailureDevices(days, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the configuration compliance status of devices; optionally filtered by domain, group, policy or compliance level.
     * @summary Get the configuration compliance status of devices
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {Set<number>} [group] Filter on given group ID(s)
     * @param {Set<number>} [policy] Filter on given policy ID(s)
     * @param {Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>} [result] Filter on given result(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getConfigComplianceDeviceStatuses(domain?: Set<number>, group?: Set<number>, policy?: Set<number>, result?: Set<'CONFORMING' | 'EXEMPTED' | 'INVALIDRULE' | 'DISABLED' | 'NONCONFORMING' | 'NOTAPPLICABLE'>, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getConfigComplianceDeviceStatuses(domain, group, policy, result, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of configurations, based on given criteria.
     * @summary Get configuration changes
     * @param {number} [after] Configs gathered after this date (as milliseconds since 1970)
     * @param {number} [before] Configs gathered before this date (as milliseconds since 1970)
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {Set<number>} [group] Filter on given group ID(s)
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getConfigs(after?: number, before?: number, domain?: Set<number>, group?: Set<number>, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getConfigs(after, before, domain, group, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exports data as Excel datasheet. The devices can be filtered by groups or domains. The report can be customized to include or not interfaces, inventory, locations, compliance, groups. The only supported and default output format is xlsx (Excel file).
     * @summary Export data
     * @param {Set<number>} [group] Filter on given group ID(s)
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {boolean} [interfaces] Whether to export interface data
     * @param {boolean} [inventory] Whether to export inventory data
     * @param {boolean} [inventoryhistory] Whether to export interface history
     * @param {boolean} [locations] Whether to export locations
     * @param {boolean} [compliance] Whether to export compliance results
     * @param {boolean} [groups] Whether to export group info
     * @param {string} [format] Export format (xlsx is supported)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getDataXLSX(group?: Set<number>, domain?: Set<number>, interfaces?: boolean, inventory?: boolean, inventoryhistory?: boolean, locations?: boolean, compliance?: boolean, groups?: boolean, format?: string, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getDataXLSX(group, domain, interfaces, inventory, inventoryhistory, locations, compliance, groups, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the compliance status of a given device group, by ID.
     * @summary Get the compliance status of a device group
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {Set<number>} [group] Filter on given group ID(s)
     * @param {Set<number>} [policy] Filter on given policy ID(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getGroupConfigComplianceStats(domain?: Set<number>, group?: Set<number>, policy?: Set<number>, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getGroupConfigComplianceStats(domain, group, policy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of non-compliance devices part of a given group, optionally filtered by domains and policies
     * @summary Get the non compliant devices of a group
     * @param {number} id Group ID
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {Set<number>} [policy] Filter on given policy ID(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getGroupConfigNonCompliantDevices(id: number, domain?: Set<number>, policy?: Set<number>, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getGroupConfigNonCompliantDevices(id, domain, policy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of devices of a given group by ID, and matching the given software compliance level.
     * @summary Get the devices of a group based on software compliance level
     * @param {number} id Group ID
     * @param {string} level Software compliance level
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getGroupDevicesBySoftwareLevel(id: number, level: string, domain?: Set<number>, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getGroupDevicesBySoftwareLevel(id, level, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the software compliance status of devices, optionally filtered by a list of device domains.
     * @summary Get the global software compliance status
     * @param {Set<number>} [domain] Filter on given domain ID(s)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getGroupSoftwareComplianceStats(domain?: Set<number>, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getGroupSoftwareComplianceStats(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of devices getting End-of-Life (type \'eol\') or End-of-Sale (type \'eos\') at the given date (or never if \'date\' is not given).
     * @summary Get the End-of-Life or End-of-Sale devices matching a date.
     * @param {string} type eos (end-of-sale) or eol (end-of-life), type of date
     * @param {number} date EoX date to filter on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getHardwareStatusDevices(type: string, date: number, options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getHardwareStatusDevices(type, date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the global hardware support status, i.e. a list of End-of-Life and End-of-Sale dates with the corresponding device count.
     * @summary Get the global hardware support status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getHardwareSupportStats(options?: AxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getHardwareSupportStats(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScriptsApi - axios parameter creator
 * @export
 */
export const ScriptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a command script (script to be later run over devices).
         * @summary Add a command script
         * @param {DeviceJsScriptRestApiView} [deviceJsScriptRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScript: async (deviceJsScriptRestApiView?: DeviceJsScriptRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scripts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deviceJsScriptRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a given script, by ID.
         * @summary Remove a script
         * @param {number} id Script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScript: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteScript', 'id', id)
            const localVarPath = `/scripts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a given command script, by ID.
         * @summary Get a command script
         * @param {number} id Script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScript: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getScript', 'id', id)
            const localVarPath = `/scripts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of command scripts.
         * @summary Get command scripts
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScripts: async (offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scripts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScriptsApi - functional programming interface
 * @export
 */
export const ScriptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScriptsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a command script (script to be later run over devices).
         * @summary Add a command script
         * @param {DeviceJsScriptRestApiView} [deviceJsScriptRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addScript(deviceJsScriptRestApiView?: DeviceJsScriptRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceJsScriptRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addScript(deviceJsScriptRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a given script, by ID.
         * @summary Remove a script
         * @param {number} id Script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScript(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScript(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a given command script, by ID.
         * @summary Get a command script
         * @param {number} id Script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScript(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceJsScriptRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScript(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of command scripts.
         * @summary Get command scripts
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScripts(offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceJsScriptRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScripts(offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScriptsApi - factory interface
 * @export
 */
export const ScriptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScriptsApiFp(configuration)
    return {
        /**
         * Create a command script (script to be later run over devices).
         * @summary Add a command script
         * @param {DeviceJsScriptRestApiView} [deviceJsScriptRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScript(deviceJsScriptRestApiView?: DeviceJsScriptRestApiView, options?: any): AxiosPromise<DeviceJsScriptRestApiView> {
            return localVarFp.addScript(deviceJsScriptRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a given script, by ID.
         * @summary Remove a script
         * @param {number} id Script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScript(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScript(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a given command script, by ID.
         * @summary Get a command script
         * @param {number} id Script ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScript(id: number, options?: any): AxiosPromise<DeviceJsScriptRestApiView> {
            return localVarFp.getScript(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of command scripts.
         * @summary Get command scripts
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScripts(offset?: number, limit?: number, options?: any): AxiosPromise<Array<DeviceJsScriptRestApiView>> {
            return localVarFp.getScripts(offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScriptsApi - object-oriented interface
 * @export
 * @class ScriptsApi
 * @extends {BaseAPI}
 */
export class ScriptsApi extends BaseAPI {
    /**
     * Create a command script (script to be later run over devices).
     * @summary Add a command script
     * @param {DeviceJsScriptRestApiView} [deviceJsScriptRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptsApi
     */
    public addScript(deviceJsScriptRestApiView?: DeviceJsScriptRestApiView, options?: AxiosRequestConfig) {
        return ScriptsApiFp(this.configuration).addScript(deviceJsScriptRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a given script, by ID.
     * @summary Remove a script
     * @param {number} id Script ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptsApi
     */
    public deleteScript(id: number, options?: AxiosRequestConfig) {
        return ScriptsApiFp(this.configuration).deleteScript(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a given command script, by ID.
     * @summary Get a command script
     * @param {number} id Script ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptsApi
     */
    public getScript(id: number, options?: AxiosRequestConfig) {
        return ScriptsApiFp(this.configuration).getScript(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of command scripts.
     * @summary Get command scripts
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScriptsApi
     */
    public getScripts(offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return ScriptsApiFp(this.configuration).getScripts(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a task and schedule it for execution.
         * @summary Add a task
         * @param {RsTaskRestApiView} [rsTaskRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTask: async (rsTaskRestApiView?: RsTaskRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsTaskRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of tasks of a given device (by ID). Tasks are returned sorted by status and significant date.
         * @summary Get device tasks
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceTasks: async (id: number, offset?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeviceTasks', 'id', id)
            const localVarPath = `/devices/{id}/tasks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the status of a given task, by ID.
         * @summary Get a task.
         * @param {number} id Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTask', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the full debug log of a given task, by ID.
         * @summary Get the debug log of a task
         * @param {number} id Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskDebugLog: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskDebugLog', 'id', id)
            const localVarPath = `/tasks/{id}/debuglog`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves global info about tasks.
         * @summary Get summary/overview of tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskSummary: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of tasks. Limited to 100 if no specific limit is provided.
         * @summary Get the tasks
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {Set<'CANCELLED' | 'FAILURE' | 'NEW' | 'RUNNING' | 'SCHEDULED' | 'SUCCESS' | 'WAITING'>} [status] Include tasks of given status(es)
         * @param {number} [after] Tasks executed or changed after this date (as milliseconds since 1970)
         * @param {number} [before] Tasks executed or changed before this date (as milliseconds since 1970)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (offset?: number, limit?: number, status?: Set<'CANCELLED' | 'FAILURE' | 'NEW' | 'RUNNING' | 'SCHEDULED' | 'SUCCESS' | 'WAITING'>, after?: number, before?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (status) {
                localVarQueryParameter['status'] = Array.from(status);
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a task, by ID. Set \'cancel\' property to true to cancel the task.
         * @summary Update a task
         * @param {number} id Task ID
         * @param {RsTaskRestApiView} [rsTaskRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTask: async (id: number, rsTaskRestApiView?: RsTaskRestApiView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setTask', 'id', id)
            const localVarPath = `/tasks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiTokenAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Netshot-API-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rsTaskRestApiView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a task and schedule it for execution.
         * @summary Add a task
         * @param {RsTaskRestApiView} [rsTaskRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTask(rsTaskRestApiView?: RsTaskRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTask(rsTaskRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of tasks of a given device (by ID). Tasks are returned sorted by status and significant date.
         * @summary Get device tasks
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeviceTasks(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeviceTasks(id, offset, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the status of a given task, by ID.
         * @summary Get a task.
         * @param {number} id Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTask(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the full debug log of a given task, by ID.
         * @summary Get the debug log of a task
         * @param {number} id Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskDebugLog(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskDebugLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves global info about tasks.
         * @summary Get summary/overview of tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskSummary(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RsTaskSummaryRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskSummary(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the list of tasks. Limited to 100 if no specific limit is provided.
         * @summary Get the tasks
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {Set<'CANCELLED' | 'FAILURE' | 'NEW' | 'RUNNING' | 'SCHEDULED' | 'SUCCESS' | 'WAITING'>} [status] Include tasks of given status(es)
         * @param {number} [after] Tasks executed or changed after this date (as milliseconds since 1970)
         * @param {number} [before] Tasks executed or changed before this date (as milliseconds since 1970)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(offset?: number, limit?: number, status?: Set<'CANCELLED' | 'FAILURE' | 'NEW' | 'RUNNING' | 'SCHEDULED' | 'SUCCESS' | 'WAITING'>, after?: number, before?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskRestApiView>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(offset, limit, status, after, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Edits a task, by ID. Set \'cancel\' property to true to cancel the task.
         * @summary Update a task
         * @param {number} id Task ID
         * @param {RsTaskRestApiView} [rsTaskRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTask(id: number, rsTaskRestApiView?: RsTaskRestApiView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskRestApiView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTask(id, rsTaskRestApiView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * Creates a task and schedule it for execution.
         * @summary Add a task
         * @param {RsTaskRestApiView} [rsTaskRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTask(rsTaskRestApiView?: RsTaskRestApiView, options?: any): AxiosPromise<TaskRestApiView> {
            return localVarFp.addTask(rsTaskRestApiView, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of tasks of a given device (by ID). Tasks are returned sorted by status and significant date.
         * @summary Get device tasks
         * @param {number} id Device ID
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeviceTasks(id: number, offset?: number, limit?: number, options?: any): AxiosPromise<Array<TaskRestApiView>> {
            return localVarFp.getDeviceTasks(id, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the status of a given task, by ID.
         * @summary Get a task.
         * @param {number} id Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(id: number, options?: any): AxiosPromise<TaskRestApiView> {
            return localVarFp.getTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the full debug log of a given task, by ID.
         * @summary Get the debug log of a task
         * @param {number} id Task ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskDebugLog(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.getTaskDebugLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves global info about tasks.
         * @summary Get summary/overview of tasks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskSummary(options?: any): AxiosPromise<RsTaskSummaryRestApiView> {
            return localVarFp.getTaskSummary(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of tasks. Limited to 100 if no specific limit is provided.
         * @summary Get the tasks
         * @param {number} [offset] Pagination offset for the first item to return
         * @param {number} [limit] Maximum number of items to return
         * @param {Set<'CANCELLED' | 'FAILURE' | 'NEW' | 'RUNNING' | 'SCHEDULED' | 'SUCCESS' | 'WAITING'>} [status] Include tasks of given status(es)
         * @param {number} [after] Tasks executed or changed after this date (as milliseconds since 1970)
         * @param {number} [before] Tasks executed or changed before this date (as milliseconds since 1970)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(offset?: number, limit?: number, status?: Set<'CANCELLED' | 'FAILURE' | 'NEW' | 'RUNNING' | 'SCHEDULED' | 'SUCCESS' | 'WAITING'>, after?: number, before?: number, options?: any): AxiosPromise<Array<TaskRestApiView>> {
            return localVarFp.getTasks(offset, limit, status, after, before, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a task, by ID. Set \'cancel\' property to true to cancel the task.
         * @summary Update a task
         * @param {number} id Task ID
         * @param {RsTaskRestApiView} [rsTaskRestApiView] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTask(id: number, rsTaskRestApiView?: RsTaskRestApiView, options?: any): AxiosPromise<TaskRestApiView> {
            return localVarFp.setTask(id, rsTaskRestApiView, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Creates a task and schedule it for execution.
     * @summary Add a task
     * @param {RsTaskRestApiView} [rsTaskRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public addTask(rsTaskRestApiView?: RsTaskRestApiView, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).addTask(rsTaskRestApiView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of tasks of a given device (by ID). Tasks are returned sorted by status and significant date.
     * @summary Get device tasks
     * @param {number} id Device ID
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getDeviceTasks(id: number, offset?: number, limit?: number, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getDeviceTasks(id, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the status of a given task, by ID.
     * @summary Get a task.
     * @param {number} id Task ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTask(id: number, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the full debug log of a given task, by ID.
     * @summary Get the debug log of a task
     * @param {number} id Task ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTaskDebugLog(id: number, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTaskDebugLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves global info about tasks.
     * @summary Get summary/overview of tasks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTaskSummary(options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTaskSummary(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of tasks. Limited to 100 if no specific limit is provided.
     * @summary Get the tasks
     * @param {number} [offset] Pagination offset for the first item to return
     * @param {number} [limit] Maximum number of items to return
     * @param {Set<'CANCELLED' | 'FAILURE' | 'NEW' | 'RUNNING' | 'SCHEDULED' | 'SUCCESS' | 'WAITING'>} [status] Include tasks of given status(es)
     * @param {number} [after] Tasks executed or changed after this date (as milliseconds since 1970)
     * @param {number} [before] Tasks executed or changed before this date (as milliseconds since 1970)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasks(offset?: number, limit?: number, status?: Set<'CANCELLED' | 'FAILURE' | 'NEW' | 'RUNNING' | 'SCHEDULED' | 'SUCCESS' | 'WAITING'>, after?: number, before?: number, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTasks(offset, limit, status, after, before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a task, by ID. Set \'cancel\' property to true to cancel the task.
     * @summary Update a task
     * @param {number} id Task ID
     * @param {RsTaskRestApiView} [rsTaskRestApiView] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public setTask(id: number, rsTaskRestApiView?: RsTaskRestApiView, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).setTask(id, rsTaskRestApiView, options).then((request) => request(this.axios, this.basePath));
    }
}


